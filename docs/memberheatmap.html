<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ShiftCommander — Member</title>
  <style>
    :root{
      --bg0:#070b14;
      --bg1:#0b1428;
      --card:#0c1a34;
      --card2:#0b1730;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --text:#e9f1ff;
      --muted:rgba(233,241,255,.72);
      --muted2:rgba(233,241,255,.50);
      --green:#26d07c;
      --blue:#5c8dff;
      --red:#ff5d5d;
      --clear:rgba(233,241,255,.26);
      --shadow:0 16px 50px rgba(0,0,0,.35);
      --r:16px;
      --r2:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background: radial-gradient(1100px 700px at 35% -20%, #163a86 0%, rgba(22,58,134,0) 55%),
                  radial-gradient(900px 600px at 90% 0%, #2a0e6e 0%, rgba(42,14,110,0) 60%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
    }

    /* Header */
    .top{
      position:sticky;
      top:0;
      z-index:20;
      background: linear-gradient(180deg, rgba(5,8,16,.92), rgba(5,8,16,.55));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
    }
    .topInner{
      max-width: 1280px;
      margin: 0 auto;
      padding: 14px 14px 12px;
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .brand{
      font-weight:800;
      letter-spacing:.2px;
      margin-right:auto;
      white-space:nowrap;
    }
    .controls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      min-width: 320px;
    }
    .pill{
      background: rgba(255,255,255,.06);
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 9px 12px;
      display:flex;
      align-items:center;
      gap:10px;
      box-shadow: 0 8px 26px rgba(0,0,0,.18);
    }
    .pill label{font-size:12px; color:var(--muted2)}
    select, input[type="date"]{
      background: transparent;
      color: var(--text);
      border: 0;
      outline: 0;
      font-size: 14px;
    }
    option{color:#000}
    .btn{
      cursor:pointer;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 999px;
      padding: 9px 12px;
      font-weight: 700;
      box-shadow: 0 8px 26px rgba(0,0,0,.18);
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:active{transform: translateY(1px)}
    .btn:hover{background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.22)}
    .btn.secondary{font-weight:700; opacity:.95}

    .dot{
      width:10px; height:10px; border-radius:999px;
      background: var(--clear);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
      flex:0 0 auto;
    }
    .dot.ok{ background: var(--green); box-shadow: 0 0 0 3px rgba(38,208,124,.16) }
    .dot.warn{ background: #f4c542; box-shadow: 0 0 0 3px rgba(244,197,66,.16) }

    /* Layout */
    .wrap{
      max-width: 1280px;
      margin: 0 auto;
      padding: 16px 14px 18px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border: 1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .headline{
      display:flex;
      align-items:flex-start;
      gap:12px;
      flex-wrap:wrap;
    }
    .headline h2{
      margin:0;
      font-size: 16px;
      line-height:1.25;
      letter-spacing:.2px;
    }
    .headline .sub{
      margin:2px 0 0;
      font-size: 12px;
      color: var(--muted);
    }
    .headline .right{
      margin-left:auto;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .statusPill{
      display:flex;
      align-items:center;
      gap:10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
      padding: 8px 10px;
      min-height: 36px;
    }
    .statusPill .tiny{
      font-size:12px;
      color: var(--muted);
      max-width: 0; /* hide by default, keep tooltip */
      overflow:hidden;
      white-space:nowrap;
    }
    .statusPill.hasText .tiny{ max-width: 420px } /* use for debug if you ever want */
    .gridWrap{
      margin-top: 14px;
      overflow-x:auto;
      border-radius: var(--r);
    }

    /* Calendar grid */
    .cal{
      min-width: 980px; /* prevents off-screen clipping; scrolls instead */
      display:grid;
      grid-template-columns: 170px repeat(7, minmax(110px, 1fr));
      gap:10px;
      padding: 10px;
      background: rgba(0,0,0,.10);
      border: 1px solid var(--line);
      border-radius: var(--r);
    }
    .wkLabel{
      padding: 12px;
      border-radius: var(--r2);
      border: 1px solid var(--line);
      background: rgba(255,255,255,.035);
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
      min-height: 92px;
    }
    .wkTag{
      display:inline-flex;
      width:fit-content;
      align-items:center;
      gap:8px;
      font-size:12px;
      font-weight:800;
      letter-spacing:.3px;
      text-transform:uppercase;
      color: var(--muted);
    }
    .wkRange{
      font-size: 12px;
      color: var(--muted);
    }
    .wkRange b{color:var(--text)}
    .hdrCell{
      padding: 10px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      font-weight: 900;
      letter-spacing:.3px;
      text-transform:uppercase;
      font-size: 12px;
      color: var(--text);
      text-align:center;
    }

    .dayCard{
      border-radius: var(--r2);
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      padding: 10px;
      min-height: 92px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .dayTop{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:10px;
    }
    .dayNum{
      font-size: 26px;
      font-weight: 950;
      line-height:1;
      letter-spacing:.2px;
    }
    .dayMini{
      font-size: 11px;
      color: var(--muted2);
      letter-spacing:.2px;
      white-space:nowrap;
    }

    .shiftRow{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
        .shiftBtn{
      border-radius: 12px;
      padding: 10px 8px;
      border: 2px solid rgba(233,241,255,.22); /* border is HEATMAP */
      background: rgba(255,255,255,.02);       /* fill is MEMBER preference */
      cursor:pointer;
      user-select:none;
      text-align:center;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
    }
    .shiftBtn:active{ transform: translateY(1px) }
    .shiftBtn.locked{ cursor: not-allowed; opacity:.55 }
    .shiftKey{ font-weight: 950; letter-spacing:.3px; font-size: 12px; }
    .shiftState{ font-size: 10px; color: var(--muted2); margin-top: 3px; letter-spacing:.2px; text-transform:uppercase; }

    /* Member preference (FILL) */
    .shiftBtn[data-state="preferred"]{ background: rgba(38,208,124,.16) }
    .shiftBtn[data-state="available"]{ background: rgba(92,141,255,.14) }
    .shiftBtn[data-state="nosched"]{   background: rgba(255,93,93,.12) }
    .shiftBtn[data-state="clear"]{     background: rgba(255,255,255,.02) }

    /* Heatmap (BORDER) — Model A (Preferred-only popularity) */
    .shiftBtn.heat-0{ border-color: rgba(38,208,124,.95); box-shadow: 0 0 0 2px rgba(38,208,124,.10) inset; }  /* Need++ */
    .shiftBtn.heat-1{ border-color: rgba(38,208,124,.55); }                                                     /* Need+  */
    .shiftBtn.heat-2{ border-color: rgba(233,241,255,.22); }                                                     /* Neutral */
    .shiftBtn.heat-3{ border-color: rgba(255,93,93,.45); }                                                       /* Crowded+ */
    .shiftBtn.heat-4{ border-color: rgba(255,93,93,.95); box-shadow: 0 0 0 2px rgba(255,93,93,.10) inset; }      /* Crowded++ */

    /* Worked state keeps its own visual */

    .shiftBtn[data-state="worked"]{
      border-style: solid;
      border-color: rgba(233,241,255,.30);
      background: rgba(255,255,255,.03);
    }
    .shiftBtn[data-state="worked"] .shiftState{ color: rgba(233,241,255,.75) }

    /* Legend */
    .legend{
      margin-top: 12px;
      display:flex;
      flex-wrap:wrap;
      gap:10px 14px;
      align-items:center;
      color: var(--muted);
      font-size: 12px;
    }
    .legItem{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      cursor: help;
      user-select:none;
      white-space:nowrap;
    }
    .swatch{
      width: 10px; height: 10px; border-radius: 999px;
      background: rgba(233,241,255,.26);
      box-shadow: 0 0 0 3px rgba(255,255,255,.05);
    }
    .swatch.pref{ background: var(--green); box-shadow: 0 0 0 3px rgba(38,208,124,.16) }
    .swatch.av{ background: var(--blue); box-shadow: 0 0 0 3px rgba(92,141,255,.16) }
    .swatch.no{ background: var(--red); box-shadow: 0 0 0 3px rgba(255,93,93,.16) }
    .swatch.cl{ background: rgba(233,241,255,.26) }

    /* Modal (Repeat/Tools) */
    dialog{
      border:none;
      padding:0;
      border-radius: 18px;
      background: #0b1730;
      color: var(--text);
      width: min(720px, calc(100vw - 24px));
      box-shadow: 0 30px 80px rgba(0,0,0,.55);
    }
    dialog::backdrop{ background: rgba(0,0,0,.55) }
    .modalHead{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--line);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .modalHead h3{ margin:0; font-size: 15px }
    .modalBody{ padding: 14px }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
    .row > *{ flex: 0 0 auto }
    .note{ font-size: 12px; color: var(--muted); line-height: 1.35 }
    .danger{ border-color: rgba(255,93,93,.55) }
    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform: translateX(-50%);
      background: rgba(10,16,30,.92);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      padding: 10px 12px;
      color: var(--text);
      font-weight: 800;
      font-size: 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.50);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index:999;
    }
    .toast.show{ opacity:1 }

    @media (max-width: 860px){
      .controls{ min-width: unset; width:100% }
      .cal{ min-width: 900px }
      .wkLabel{ min-height: 86px }
    }
  </style>
</head>
<body>
  <div class="top">
    <div class="topInner">
      <div class="brand">ShiftCommander — Member</div>

      <div class="controls">
        <div class="pill" title="Organization">
          <label>Org:</label>
          <span id="orgName" style="font-weight:900"></span>
        </div>

        <div class="pill" title="Select yourself">
          <label>Member:</label>
          <select id="memberSel"></select>
        </div>

        <button class="btn secondary" id="btnPrev">◀</button>
        <button class="btn secondary" id="btnThis">This Week</button>
        <button class="btn secondary" id="btnNext">▶</button>

        <div class="pill" title="Jump to a week start">
          <label>Week start:</label>
          <input id="weekPick" type="date"/>
        </div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="card">
      <div class="headline">
        <div>
          <h2>Set your availability</h2>
          <div class="sub">Tap AM/PM to cycle: Preferred → Available → Do not schedule → Clear.</div>
        </div>

        <div class="right">
          <div class="statusPill" id="savepill" title="Drive status">
            <span class="dot warn" id="driveDot"></span>
            <span class="tiny" id="driveTip">Checking…</span>
          </div>
          <button class="btn" id="btnTools">Repeat / Tools</button>
        </div>
      </div>

      <div class="gridWrap">
        <div class="cal" id="cal"></div>
      </div>

      <div class="legend" aria-label="Availability legend">
        <span class="legItem" title="Preferred — You WANT this shift.">
          <span class="swatch pref"></span> Preferred
        </span>
        <span class="legItem" title="Available — You CAN work this shift and will be considered if not filled by someone who PREFERS it (then weighted fairly).">
          <span class="swatch av"></span> Available
        </span>
        <span class="legItem" title="Do not schedule — You will not be considered for this shift.">
          <span class="swatch no"></span> Do not schedule
        </span>
        <span class="legItem" title="Clear / unset — No preference stated. You may still be considered only if no one prefers or is available (and fairness allows it).">
          <span class="swatch cl"></span> Clear
        </span>
      </div>
    </div>
  </div>

  <dialog id="toolsDlg">
    <div class="modalHead">
      <h3>Repeat / Tools</h3>
      <div style="margin-left:auto"></div>
      <button class="btn secondary" id="btnCloseDlg">Close</button>
    </div>
    <div class="modalBody">
      <div class="note">
        Pick a <b>Pattern Week</b> (any week) and repeat it forward. The current work week may be restricted — your pattern doesn’t have to be.
      </div>

      <div style="height:10px"></div>

      <div class="row" style="align-items:center">
        <div class="pill" title="The week used as the source for repeats">
          <label>Pattern:</label>
          <span id="patternLabel" style="font-weight:900"></span>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="row">
        <button class="btn" id="copyPatternNext">Copy <b>Pattern</b> → next week</button>
        <button class="btn" id="copyPatternPublished">Copy <b>Pattern</b> → all <b>Published</b> weeks</button>
        <button class="btn danger" id="clearPatternWeek">Clear <b>Pattern</b> week</button>
      </div>

      <div style="height:14px"></div>

      <div style="border:1px solid var(--line); border-radius:16px; padding:12px; background: rgba(255,255,255,.03);">
        <div style="font-weight:900; margin-bottom:6px;">Repeat into Planning</div>
        <div class="note" style="margin-bottom:10px;">
          Repeat the <b>Pattern Week</b> every X weeks, starting in <b>Planning</b>, until the date you choose.
        </div>

        <div class="row" style="align-items:center">
          <label class="note">Every</label>
          <select id="repeatEvery" title="Repeat interval">
            <option value="2">2 weeks</option>
            <option value="4">4 weeks</option>
          </select>

          <label class="note">until</label>
          <input type="date" id="repeatUntil" title="Last date to fill (inclusive)"/>

          <button class="btn" id="btnRepeatPlanning">Repeat → Planning</button>
        </div>
      </div>

      <div style="height:12px"></div>

      <label class="note" style="display:flex; align-items:center; gap:10px; cursor:pointer; user-select:none">
        <input type="checkbox" id="overwriteLocks" style="transform:scale(1.1)" />
        Overwrite future manual picks (ignore locks)
      </label>

      <div style="height:10px"></div>
      <div class="note">
        By default, repeats won’t overwrite future dates you already touched. Check “Overwrite…” only when you mean it.
      </div>
    </div>
  </dialog>

  <div class="toast" id="toast"></div>

<script>
/* =========================
   Config
========================= */
const ORG_SETTINGS_URL = "/data/org_settings.json";
const MEMBERS_URL      = "/data/members.json";

/* Google Apps Script JSON store (you already deployed this) */
const STORE_URL = "https://script.google.com/macros/s/AKfycbyHus2_cZOds7sCMxNlGzcJq0nEEtdZwS7JwKdlV-h0o_hctGCz1OpwANZ3nHLgOIa-ug/exec";

/* lead window + display window */
const LEAD_DAYS = 21;          // suppress supervisor-style “Needs…” until 3 weeks out (member page still allows edits)
const WEEKS_SHOWN = 5;         // editing week + 4 upcoming

/* =========================
   Helpers
========================= */
const $ = (id)=>document.getElementById(id);

function todayISO(){
  const t = new Date();
  return new Date(t.getFullYear(), t.getMonth(), t.getDate()).toISOString().slice(0,10);
}
function addDaysISO(dateISO, days){
  const d = new Date(dateISO + "T00:00:00");
  d.setDate(d.getDate()+days);
  return d.toISOString().slice(0,10);
}
function weekStartISO(anyDateISO){
  // week starts Thu (ADR’s planning cadence)
  const d = new Date(anyDateISO + "T00:00:00");
  const dow = d.getDay(); // 0 Sun..6 Sat
  const THU = 4;
  const delta = (dow - THU + 7) % 7;
  d.setDate(d.getDate() - delta);
  return d.toISOString().slice(0,10);
}
function fmtMD(dateISO){
  // no year anywhere
  const d = new Date(dateISO + "T00:00:00");
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return mm + "/" + dd;
}
function dayName(dateISO){
  // Thu, Fri, ...
  return ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][new Date(dateISO+"T00:00:00").getDay()];
}
function isPast(dateISO){
  return dateISO < todayISO();
}
function toast(msg){
  const t = $("toast");
  t.textContent = msg;
  t.classList.add("show");
  clearTimeout(toast._t);
  toast._t=setTimeout(()=>t.classList.remove("show"), 1600);
}

/* =========================
   Local + Remote State
========================= */
function lsKey(memberId){ return "sc_member_" + memberId; }
function lsMetaKey(memberId){ return "sc_member_meta_" + memberId; } // {dirty:boolean,lastPushISO,lastError:string}

function getLocal(memberId){
  try{ return JSON.parse(localStorage.getItem(lsKey(memberId)) || "{}"); }catch(e){ return {}; }
}
function setLocal(memberId, obj){
  localStorage.setItem(lsKey(memberId), JSON.stringify(obj));
}
function getMeta(memberId){
  try{ return JSON.parse(localStorage.getItem(lsMetaKey(memberId)) || "{}"); }catch(e){ return {}; }
}
function setMeta(memberId, meta){
  localStorage.setItem(lsMetaKey(memberId), JSON.stringify(meta));
}

async function storeGet(kind, memberId){
  const url = new URL(STORE_URL);
  url.searchParams.set("kind", kind);
  if(memberId) url.searchParams.set("memberId", memberId);
  // token is enforced server-side; for member page we rely on the script property token
  // (If you later require client token, we’ll add it to org_settings.json and read it here.)
  const r = await fetch(url.toString(), { method:"GET", cache:"no-store" });
  if(!r.ok) throw new Error("store GET " + r.status);
  return await r.json();
}

async function storePut(kind, memberId, payload){
  const body = { kind, memberId, payload };
  const r = await fetch(STORE_URL, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify(body),
  });
  if(!r.ok) throw new Error("store POST " + r.status);
  return await r.json();
}

/* auto-sync: if we had edits while “offline”, push when online resumes */
async function trySync(memberId){
  const meta = getMeta(memberId);
  if(!meta.dirty) return true;

  try{
    const payload = getLocal(memberId);
    await storePut("member", memberId, payload);
    meta.dirty = false;
    meta.lastError = "";
    meta.lastPushISO = new Date().toISOString();
    setMeta(memberId, meta);
    setDriveStatus(meta);
    return true;
  }catch(e){
    meta.lastError = String(e.message || e);
    setMeta(memberId, meta);
    setDriveStatus(meta);
    return false;
  }
}

/* Drive status UI: only colors (green/yellow). Full meaning via hover tooltip. */
function setDriveStatus(meta){
  const dot = $("driveDot");
  const tip = $("driveTip");
  const online = navigator.onLine !== false;

  // GREEN always means: your changes are saved locally on this device.
  dot.classList.remove("ok","warn");
  dot.classList.add("ok");

  // Keep the visible text SHORT (no wrapping).
  let short = "Saved";
  if(!online) short = "Saved";
  else if(meta && meta.dirty) short = "Saved";
  tip.textContent = short;

  // Tooltip carries the nuance (sync pending / last push / error).
  const parts = [];
  parts.push("Saved locally on this device.");
  if(!online){
    parts.push("Offline: will sync to Drive when internet returns.");
  }else if(meta && meta.dirty){
    parts.push("Sync to Drive pending.");
  }else{
    parts.push("Synced to Drive.");
  }
  if(meta && meta.lastPushISO) parts.push("Last Drive sync: " + new Date(meta.lastPushISO).toLocaleString());
  if(meta && meta.lastError) parts.push("Drive sync issue: " + meta.lastError);
  $("savepill").title = parts.join(" ");
}

/* =========================
   History (optional)
   Files live at /data/history/YYYY-MM.normalized.json (if present).
========================= */
const historyCache = new Map(); // "YYYY-MM" -> normalized month json

async function loadHistoryMonth(yyyyMM){
  if(historyCache.has(yyyyMM)) return historyCache.get(yyyyMM);
  try{
    const r = await fetch(`/data/history/${yyyyMM}.normalized.json`, { cache:"no-store" });
    if(!r.ok) throw new Error("history " + r.status);
    const j = await r.json();
    historyCache.set(yyyyMM, j);
    return j;
  }catch(e){
    historyCache.set(yyyyMM, null);
    return null;
  }
}
function memberWorked(historyMonth, dateISO, half, memberId){
  if(!historyMonth || !historyMonth.days || !historyMonth.days[dateISO]) return false;
  const d = historyMonth.days[dateISO];
  const obj = d[half];
  if(!obj) return false;
  // check any seat member_id match
  for(const k of Object.keys(obj)){
    const v = obj[k];
    if(v && typeof v === "object" && v.member_id && String(v.member_id) === String(memberId)){
      return true;
    }
  }
  return false;
}

/* =========================
   Availability Model
========================= */
const cycle = ["preferred","available","nosched","clear"];
const stateLabelTiny = {
  preferred:"Preferred",
  available:"Available",
  nosched:"Do not schedule",
  clear:"Clear",
  worked:"Worked"
};

function getStateFor(memberState, dateISO, half){
  return (memberState?.[dateISO]?.[half]) || "clear";
}
function setStateFor(memberState, dateISO, half, val){
  if(!memberState[dateISO]) memberState[dateISO] = {};
  memberState[dateISO][half] = val;
}


/* =========================
   Heatmap (BORDER) — Model A (Preferred-only)
   - Border shows how "crowded" a shift is among eligible members.
   - Fill color remains the member's own preference.
   - Managed week: no heat (neutral), because changes require supervision.
========================= */
const allStates = new Map();   // memberId -> availability payload (object)
let heatLoading = false;
let heatReady = false;

function eligibleMembersForHeat(){
  // Model A asks for "qualified and interested" — we only have roster here.
  // Default eligibility: active members. (If later you add quals, put the filter here.)
  return members.filter(m => m && m.active !== false);
}

function getOtherMemberState(mid){
  if(String(mid) === String(memberId)) return memberState || {};
  return allStates.get(String(mid)) || {};
}

async function loadAllMemberStates(){
  if(heatLoading || heatReady) return;
  heatLoading = true;

  const ids = eligibleMembersForHeat().map(m=>String(m.id)).filter(Boolean);

  // Concurrency-limited fetch (keeps Apps Script happy)
  const limit = 6;
  let i = 0;

  async function worker(){
    while(i < ids.length){
      const mid = ids[i++];

      if(allStates.has(mid)) continue;
      if(String(mid) === String(memberId)) continue;

      try{
        const remote = await storeGet("member", mid);
        if(remote && remote.payload && typeof remote.payload === "object"){
          allStates.set(mid, remote.payload);
        }else{
          allStates.set(mid, {});
        }
      }catch(e){
        // Don't block heatmap if one member fails.
        allStates.set(mid, {});
      }
    }
  }

  await Promise.all(Array.from({length:limit}, worker));

  heatReady = true;
  heatLoading = false;

  // Update borders once we have data.
  applyHeatToVisible();
}

function heatLevelForShift(dateISO, half, weekTagName){
  // Only show heat for Published + Planning
  if(weekTagName !== "Published" && weekTagName !== "Planning") return 2;

  const elig = eligibleMembersForHeat();
  const E = elig.length;
  if(E <= 0) return 2;

  // Preferred-only count across eligible members
  let R = 0;
  for(const m of elig){
    const st = getStateFor(getOtherMemberState(m.id), dateISO, half);
    if(st === "preferred") R++;
  }

  // Small-roster correction
  if(E < 4){
    if(R === 0) return 0;
    if(R === 1) return 1;
    if(R === 2) return 2;
    return 4;
  }

  const r = R / E;
  if(r < 0.10) return 0;
  if(r < 0.25) return 1;
  if(r < 0.50) return 2;
  if(r < 0.75) return 3;
  return 4;
}

function heatTooltip(dateISO, half, weekTagName){
  if(weekTagName !== "Published" && weekTagName !== "Planning") return "";
  const elig = eligibleMembersForHeat();
  const E = elig.length;
  if(E <= 0) return "";

  let R = 0;
  for(const m of elig){
    const st = getStateFor(getOtherMemberState(m.id), dateISO, half);
    if(st === "preferred") R++;
  }
  const pct = Math.round((R / E) * 100);
  let band = "Neutral";
  const lvl = heatLevelForShift(dateISO, half, weekTagName);
  if(lvl === 0) band = "Need++ (low interest)";
  else if(lvl === 1) band = "Need+ (low interest)";
  else if(lvl === 3) band = "Crowded+ (high interest)";
  else if(lvl === 4) band = "Crowded++ (very high interest)";
  return `Popularity: ${R}/${E} eligible prefer (${pct}%). ${band}.`;
}

function applyHeatToVisible(){
  // If we don't have data yet, don't paint anything loud.
  const buttons = document.querySelectorAll(".shiftBtn");
  for(const btn of buttons){
    const dateISO = btn.dataset.date;
    const half = btn.dataset.half;

    // Leave worked/past alone.
    if(btn.dataset.state === "worked") continue;

    const ws = weekStartISO(dateISO);
    const tag = weekTag(ws);

    // Strip old heat classes
    btn.classList.remove("heat-0","heat-1","heat-2","heat-3","heat-4");

    // If we can't compute yet, keep neutral.
    let lvl = 2;
    if(heatReady){
      lvl = heatLevelForShift(dateISO, half, tag);
    }
    btn.classList.add("heat-" + lvl);

    // Append a short tooltip line (but keep member state as first).
    const base = `${dayName(dateISO)} ${fmtMD(dateISO)} ${half} — ${stateLabelTiny[btn.dataset.state] || btn.dataset.state}`;
    const ht = heatReady ? heatTooltip(dateISO, half, tag) : "";
    btn.title = ht ? (base + " • " + ht) : base;
  }
}
/* “manual lock” dates to prevent copy-overwrite:
   if user touched a specific date, we mark it locked in meta.locks[dateISO]=true */
function getLocks(memberId){
  const meta = getMeta(memberId);
  return meta.locks || {};
}

function getPatternWeek(memberId){
  const meta = getMeta(memberId);
  const v = meta.patternWeekStart;
  if(v) return v;
  // default: first Published week (next week after Managed)
  return addDaysISO(managedWeekStart, 7);
}
function setPatternWeek(startISO){
  patternWeekStart = startISO;
  const meta = getMeta(memberId);
  meta.patternWeekStart = startISO;
  setMeta(memberId, meta);
  updatePatternLabel();
  render();
}
function updatePatternLabel(){
  const el = $("patternLabel");
  if(!el) return;
  el.textContent = weekRangeLabel(patternWeekStart);
}
function setLocked(memberId, dateISO){
  const meta = getMeta(memberId);
  meta.locks = meta.locks || {};
  meta.locks[dateISO] = true;
  setMeta(memberId, meta);
}

/* =========================
   Render
========================= */
let orgSettings = null;
let members = [];
let memberId = null;
let editWeekStart = weekStartISO(todayISO());

let managedWeekStart = weekStartISO(todayISO());
let patternWeekStart = addDaysISO(managedWeekStart, 7); // default: first Published week

let memberState = {}; // availability map
let locks = {}; // dateISO -> true
let suppressEditPast = true;

function weekRangeLabel(startISO){
  const end = addDaysISO(startISO, 6);
  return `${fmtMD(startISO)} – ${fmtMD(end)}`;
}

function weekTag(startISO){
  const t = todayISO();
  const managed = managedWeekStart;
  const end = addDaysISO(startISO, 6);

  // Past (entire week ended before today)
  if(end < t) return "Past";

  // Managed = the week containing today (current work week)
  const managedEnd = addDaysISO(managed, 6);
  if(startISO <= t && t <= end) return "Managed";

  // Published = the next 3 full weeks after Managed
  const pubStart = addDaysISO(managed, 7);
  const pubEnd = addDaysISO(managed, 27); // 3 weeks after: +7..+27 inclusive
  if(startISO >= pubStart && startISO <= pubEnd) return "Published";

  // Planning = everything after Published
  return "Planning";
}

function buildHeaderRow(container){
  // blank corner
  const corner = document.createElement("div");
  corner.className = "hdrCell";
  corner.style.opacity = ".85";
  corner.textContent = "Week";
  container.appendChild(corner);

  // day headers based on editWeekStart
  for(let i=0;i<7;i++){
    const dateISO = addDaysISO(editWeekStart, i);
    const h = document.createElement("div");
    h.className = "hdrCell";
    h.textContent = dayName(dateISO);
    container.appendChild(h);
  }
}

function buildWeekRow(container, startISO, idx){
  const tag = weekTag(startISO);

  const label = document.createElement("div");
  label.className = "wkLabel";
  const t = document.createElement("div");
  t.className = "wkTag";

  const dotClass = (tag==="Managed" || tag==="Published") ? "ok" : "warn";
  const isPattern = (startISO === patternWeekStart);

  t.innerHTML = `<span class="dot ${dotClass}"></span>${tag}${isPattern ? ' <span style="margin-left:6px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.04); font-size:11px; font-weight:950;">PATTERN</span>' : ''}`;

  const r = document.createElement("div");
  r.className = "wkRange";
  r.innerHTML = `<b>${weekRangeLabel(startISO)}</b>`;

  const pb = document.createElement("button");
  pb.className = "btn secondary";
  pb.style.padding = "7px 10px";
  pb.style.borderRadius = "999px";
  pb.style.fontSize = "12px";
  pb.textContent = "Set Pattern";
  pb.title = "Use this week as your repeating Pattern Week";
  pb.addEventListener("click", (ev)=>{ ev.stopPropagation(); setPatternWeek(startISO); });

  label.appendChild(t);
  label.appendChild(r);
  label.appendChild(pb);
  container.appendChild(label);

  for(let i=0;i<7;i++){
    const dateISO = addDaysISO(startISO, i);
    const day = document.createElement("div");
    day.className = "dayCard";

    const top = document.createElement("div");
    top.className = "dayTop";
    const num = document.createElement("div");
    num.className = "dayNum";
    num.textContent = String(new Date(dateISO+"T00:00:00").getDate());
    const mini = document.createElement("div");
    mini.className = "dayMini";
    mini.textContent = fmtMD(dateISO);
    top.appendChild(num);
    top.appendChild(mini);

    const row = document.createElement("div");
    row.className = "shiftRow";

    const isLockedPast = isPast(dateISO) && suppressEditPast;
    const isManualLocked = !!locks[dateISO];
    const editable = !isLockedPast;

    // optional history “worked” badge for past
    const monthKey = dateISO.slice(0,7);
    const hist = historyCache.get(monthKey) || null;

    for(const half of ["AM","PM"]){
      const btn = document.createElement("div");
      btn.className = "shiftBtn";
      btn.dataset.date = dateISO;
      btn.dataset.half = half;

      let state = getStateFor(memberState, dateISO, half);

      if(isPast(dateISO)){
        // If history says you worked, show that (read-only visual)
        if(hist && memberWorked(hist, dateISO, half, memberId)) state = "worked";
      }

      btn.dataset.state = state;
      btn.title = `${dayName(dateISO)} ${fmtMD(dateISO)} ${half} — ${stateLabelTiny[state] || state}`;

      if(!editable || state==="worked"){
        btn.classList.add("locked");
      }

      const key = document.createElement("div");
      key.className = "shiftKey";
      key.textContent = half;

      const st = document.createElement("div");
      st.className = "shiftState";
      // TINY labels only
      st.textContent = state==="clear" ? "" : (state==="nosched" ? "NO" : (state==="preferred" ? "PREF" : (state==="available" ? "AVL" : state.toUpperCase())));
      btn.appendChild(key);
      btn.appendChild(st);

      btn.addEventListener("click", async ()=>{
        if(!editable) return;
        if(btn.dataset.state === "worked") return;

        const cur = btn.dataset.state || "clear";
        const nxt = cycle[(cycle.indexOf(cur)+1) % cycle.length];
        btn.dataset.state = nxt;
        btn.title = `${dayName(dateISO)} ${fmtMD(dateISO)} ${half} — ${stateLabelTiny[nxt]}`;
        st.textContent = nxt==="clear" ? "" : (nxt==="nosched" ? "NO" : (nxt==="preferred" ? "PREF" : "AVL"));

        setStateFor(memberState, dateISO, half, nxt);
        setLocal(memberId, memberState);
        setLocked(memberId, dateISO);

        const meta = getMeta(memberId);
        meta.dirty = true;
        setMeta(memberId, meta);
        setDriveStatus(meta);
        applyHeatToVisible();

        // try push in background (doesn't block UI)
        const ok = await trySync(memberId);
        if(ok) toast("Saved");
      });

      row.appendChild(btn);
    }

    // subtle lock indicator if manual date exists (visual only)
    if(isManualLocked){
      day.style.borderColor = "rgba(233,241,255,.18)";
    }

    day.appendChild(top);
    day.appendChild(row);
    container.appendChild(day);
  }
}

async function render(){
  const cal = $("cal");
  cal.innerHTML = "";
  buildHeaderRow(cal);

  // preload history months for weeks shown (best-effort)
  const months = new Set();
  for(let w=0; w<WEEKS_SHOWN; w++){
    const ws = addDaysISO(editWeekStart, w*7);
    for(let i=0;i<7;i++) months.add(addDaysISO(ws,i).slice(0,7));
  }
  await Promise.all([...months].map(loadHistoryMonth));

  // stitch loaded history into cache (loadHistoryMonth stored null on failure)
  for(const m of months){
    if(!historyCache.has(m)){
      // loadHistoryMonth stores to cache, but in case it didn't:
      historyCache.set(m, null);
    }
  }

  for(let w=0; w<WEEKS_SHOWN; w++){
    buildWeekRow(cal, addDaysISO(editWeekStart, w*7), w);
  }

  // Paint heat borders (neutral if not ready). Then load heat data in background.
  applyHeatToVisible();
  loadAllMemberStates();
}

/* =========================
   Repeat / Tools
========================= */
function copyWeekPattern(srcWeekStartISO, dstWeekStartISO, respectLocks=true){
  // copies availability from src week -> dst week
  // Default: SKIPS future dates you already touched (manual locks).
  for(let i=0;i<7;i++){
    const srcDay = addDaysISO(srcWeekStartISO, i);
    const dstDay = addDaysISO(dstWeekStartISO, i);
    if(respectLocks && locks[dstDay]) continue; // don't overwrite hand-picked dates unless requested
    for(const half of ["AM","PM"]){
      const v = getStateFor(memberState, srcDay, half);
      setStateFor(memberState, dstDay, half, v);
    }
  }
}
async function persistAfterBulkEdit(){
  setLocal(memberId, memberState);
  const meta = getMeta(memberId);
  meta.dirty = true;
  setMeta(memberId, meta);
  setDriveStatus(meta);
  await render();
  const ok = await trySync(memberId);
  if(ok) toast("Saved");
}
$("btnTools").addEventListener("click", ()=> { updatePatternLabel(); $("toolsDlg").showModal(); });
$("btnCloseDlg").addEventListener("click", ()=> $("toolsDlg").close());

$("copyPatternNext").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks")?.checked === true;
  copyWeekPattern(patternWeekStart, addDaysISO(patternWeekStart, 7), !overwrite);
  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

$("copyPatternPublished").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks")?.checked === true;
  // Published = next 3 weeks after Managed
  const pubStart = addDaysISO(managedWeekStart, 7);
  for(let w=0; w<3; w++){
    const dst = addDaysISO(pubStart, w*7);
    copyWeekPattern(patternWeekStart, dst, !overwrite);
  }
  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

$("clearPatternWeek").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks")?.checked === true;
  for(let i=0;i<7;i++){
    const day = addDaysISO(patternWeekStart, i);
    if(!overwrite && locks[day]) continue;
    for(const half of ["AM","PM"]){
      setStateFor(memberState, day, half, "clear");
    }
  }
  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

function planningWeekStart(){
  // Planning begins after Managed + 3 Published weeks
  return addDaysISO(managedWeekStart, 28);
}

$("btnRepeatPlanning").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks")?.checked === true;
  const every = parseInt($("repeatEvery")?.value || "4", 10);
  const until = $("repeatUntil")?.value || "";

  if(!until){
    toast("Pick an 'until' date");
    return;
  }
  const untilWeek = weekStartISO(until);
  const startPlanning = planningWeekStart();

  // Repeat pattern forward every N weeks, but only fill Planning weeks.
  for(let wStart = patternWeekStart; wStart <= untilWeek; ){
    // advance first (we don't need to "repeat" into the pattern itself)
    wStart = addDaysISO(wStart, every*7);
    if(wStart > untilWeek) break;
    if(addDaysISO(wStart, 6) < todayISO()) continue; // skip fully past
    if(wStart < startPlanning) continue; // keep this button "Planning only"
    copyWeekPattern(patternWeekStart, wStart, !overwrite);
  }

  await persistAfterBulkEdit();
  $("toolsDlg").close();
});
/* =========================
   Boot
========================= */
async function loadRequired(){
  const [orgR, memR] = await Promise.all([
    fetch(ORG_SETTINGS_URL, {cache:"no-store"}),
    fetch(MEMBERS_URL, {cache:"no-store"})
  ]);
  if(!orgR.ok) throw new Error("Fetch failed " + orgR.status + ": " + ORG_SETTINGS_URL);
  if(!memR.ok) throw new Error("Fetch failed " + memR.status + ": " + MEMBERS_URL);

  orgSettings = await orgR.json();

  const memJson = await memR.json();

  // Accept BOTH shapes:
  // 1) legacy: [ {id, first, last, ...}, ... ]
  // 2) current: { version, updated_at, members: [ {member_id, first_name, last_name, ...}, ... ] }
  let rawMembers = memJson;
  if(Array.isArray(memJson)) rawMembers = memJson;
  else if(memJson && Array.isArray(memJson.members)) rawMembers = memJson.members;
  else throw new Error("members is not iterable (unexpected members.json shape)");

  // Normalize to the fields this page uses
  members = rawMembers.map(m => ({
    // unify id field
    id: String(m.id ?? m.member_id ?? ""),
    first: (m.first ?? m.first_name ?? "").trim(),
    last: (m.last ?? m.last_name ?? "").trim(),
    active: (m.active !== false),
    _raw: m
  })).filter(m => m.id);

  // Org name (supports both shapes)
  const orgName = orgSettings?.org_name || orgSettings?.org?.name || "Org";
  $("orgName").textContent = orgName;

  // member dropdown
  const sel = $("memberSel");
  sel.innerHTML = "";
  for(const m of members){
    const opt = document.createElement("option");
    opt.value = m.id;
    opt.textContent = `${m.last || ""}, ${m.first || ""} #${m.id}`;
    sel.appendChild(opt);
  }
  memberId = String(members?.[0]?.id || "");
  sel.value = memberId;
}

async function loadMember(){
  managedWeekStart = weekStartISO(todayISO());
  patternWeekStart = getPatternWeek(memberId);
  locks = getLocks(memberId);

  // start with local
  memberState = getLocal(memberId) || {};
  let meta = getMeta(memberId);

  // show “ok” if last push exists and not dirty
  const optimisticOk = !!meta.lastPushISO && !meta.dirty && (navigator.onLine !== false);
  setDriveStatus(meta);

  // pull remote if available, but do NOT clobber local if local is dirty
  try{
    const remote = await storeGet("member", memberId);
    if(remote && remote.payload){
      if(!meta.dirty){
        memberState = remote.payload;
        setLocal(memberId, memberState);
      }
      meta.lastError = "";
      setMeta(memberId, meta);
      setDriveStatus(meta);
    }
  }catch(e){
    meta.lastError = String(e.message || e);
    setMeta(memberId, meta);
    setDriveStatus(meta);
  }

  // if we had dirty edits, try sync once on load
  await trySync(memberId);

  updatePatternLabel();
  await render();
}

function setEditWeekStart(newStartISO){
  editWeekStart = weekStartISO(newStartISO);
  $("weekPick").value = editWeekStart;
  render();
}

$("memberSel").addEventListener("change", async (e)=>{
  memberId = String(e.target.value);
  await loadMember();
});

$("btnPrev").addEventListener("click", ()=>{
  setEditWeekStart(addDaysISO(editWeekStart, -7));
});
$("btnNext").addEventListener("click", ()=>{
  setEditWeekStart(addDaysISO(editWeekStart, 7));
});
$("btnThis").addEventListener("click", ()=>{
  setEditWeekStart(todayISO());
});
$("weekPick").addEventListener("change", (e)=>{
  if(e.target.value) setEditWeekStart(e.target.value);
});

// Online/offline events: if we come back online, push dirty edits automatically
window.addEventListener("online", ()=> { if(memberId) trySync(memberId); });
window.addEventListener("offline", ()=> { if(memberId){ const m=getMeta(memberId); setDriveStatus(m);} });

(async function boot(){
  try{
    await loadRequired();
    setEditWeekStart(todayISO());
    // default "repeat until" = 6 months out
    const ru = $("repeatUntil");
    if(ru){
      const d = new Date();
      d.setMonth(d.getMonth()+6);
      ru.value = d.toISOString().slice(0,10);
    }
    await loadMember();
  }catch(e){
    alert("Member page failed to load required data:\n\n" + (e.message || e));
    console.error(e);
  }
})();
</script>
</body>
</html>
