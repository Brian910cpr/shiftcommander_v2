<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Drive Store Debug — Apps Script /exec + Token</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h1 { margin: 0 0 8px 0; font-size: 18px; }
    .row { display: grid; grid-template-columns: 160px 1fr; gap: 8px; margin: 8px 0; align-items: center; }
    input, textarea, select, button { font: inherit; padding: 8px; }
    textarea { width: 100%; min-height: 120px; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    button { cursor: pointer; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .small { font-size: 12px; color: #555; }
    .ok { color: #0a7; font-weight: 700; }
    .bad { color: #c22; font-weight: 700; }
    .warn { color: #a60; font-weight: 700; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #f3f3f3; }
    .hint { color: #333; background: #fafafa; border-left: 4px solid #ddd; padding: 10px; border-radius: 6px; }
  </style>
</head>
<body>
  <h1>Drive Store Debug — Apps Script /exec + Token (No OAuth)</h1>
  <div class="hint">
    This page tests your Store endpoint exactly like Member/Wallboard/Supervisor do:
    <span class="pill mono">GET ?token=…&kind=…&member_id=…</span> and
    <span class="pill mono">POST {token, kind, member_id, payload}</span>.
    If you see HTML starting with <span class="mono">&lt;!DOCTYPE html&gt;</span>, you’re not hitting the JSON API (deployment/auth/URL mismatch).
  </div>

  <div class="card">
    <div class="row">
      <label>Endpoint URL</label>
      <input id="endpoint" class="mono" placeholder="https://script.google.com/macros/s/XXXX/exec  OR  https://adr-fr.org/api/store" />
    </div>
    <div class="row">
      <label>Token</label>
      <input id="token" class="mono" placeholder="long hex token" />
    </div>
    <div class="row">
      <label>Kind (table)</label>
      <input id="kind" class="mono" value="debug_file" />
    </div>
    <div class="row">
      <label>member_id / key</label>
      <input id="key" class="mono" value="test" />
    </div>
    <div class="row">
      <label>Mode</label>
      <select id="mode">
        <option value="both">Use member_id in query + body</option>
        <option value="queryOnly">Query only (GET uses member_id; POST sends key too)</option>
      </select>
    </div>

    <div class="row">
      <label>POST Content-Type</label>
      <select id="postContentType">
        <option value="text/plain;charset=utf-8">text/plain;charset=utf-8 (most reliable for Apps Script)</option>
        <option value="application/json">application/json</option>
      </select>
    </div>

    <div class="row">
      <label>Cache</label>
      <select id="cacheMode">
        <option value="no-store">no-store (recommended)</option>
        <option value="reload">reload</option>
        <option value="default">default</option>
      </select>
    </div>

    <div class="btns">
      <button id="btnWrite">Write Random Payload (POST)</button>
      <button id="btnRead">Read Payload (GET)</button>
      <button id="btnWriteThenRead">Write → Read</button>
      <button id="btnPing">Ping (GET kind=ping)</button>
      <button id="btnClear">Clear Output</button>
    </div>

    <div class="row">
      <label>Payload (editable)</label>
      <textarea id="payload" class="mono"></textarea>
    </div>

    <div class="small">
      Tip: Change <span class="mono">kind</span> and <span class="mono">member_id</span> to replicate exactly what each module uses.
      If it “writes” but doesn’t “show,” it’s usually reading a different <span class="mono">kind</span>.
    </div>
  </div>

  <div class="grid2" style="margin-top: 12px;">
    <div class="card">
      <div><strong>Status</strong></div>
      <div id="statusLine" class="mono small">—</div>
      <div style="margin-top:8px;"><strong>First 200 chars (quick tell)</strong></div>
      <pre id="first200" class="mono small" style="white-space:pre-wrap; word-break:break-word;">—</pre>
      <div style="margin-top:8px;"><strong>Parsed JSON (if possible)</strong></div>
      <pre id="parsed" class="mono small" style="white-space:pre-wrap; word-break:break-word;">—</pre>
    </div>

    <div class="card">
      <div><strong>Raw Response</strong></div>
      <pre id="raw" class="mono small" style="white-space:pre-wrap; word-break:break-word; max-height: 420px; overflow:auto;">—</pre>
    </div>
  </div>

<script>
  // ---------- helpers ----------
  const $ = (id) => document.getElementById(id);

  function nowIso() { return new Date().toISOString(); }
  function randHex(n=12) {
    const chars = "0123456789abcdef";
    let s = "";
    for (let i=0;i<n;i++) s += chars[Math.floor(Math.random()*chars.length)];
    return s;
  }

  function setDefaultPayload() {
    const p = {
      updated_at: nowIso(),
      debug: true,
      random: randHex(16),
      browser: navigator.userAgent,
      note: "If you can read this back, the Store works end-to-end."
    };
    $("payload").value = JSON.stringify(p, null, 2);
  }

  function formatStatus(ok, text) {
    const el = $("statusLine");
    el.innerHTML = ok ? `<span class="ok">OK</span> ${text}` : `<span class="bad">FAIL</span> ${text}`;
  }

  function warnStatus(text) {
    $("statusLine").innerHTML = `<span class="warn">WARN</span> ${text}`;
  }

  function clearOutput() {
    $("statusLine").textContent = "—";
    $("raw").textContent = "—";
    $("first200").textContent = "—";
    $("parsed").textContent = "—";
  }

  function buildGetUrl({ endpoint, token, kind, key }) {
    const u = new URL(endpoint);
    u.searchParams.set("token", token);
    u.searchParams.set("kind", kind);
    u.searchParams.set("member_id", key);
    // extra anti-cache param that won't hurt:
    u.searchParams.set("_ts", Date.now().toString());
    return u.toString();
  }

  async function doFetchText(url, opts) {
    const t0 = performance.now();
    const res = await fetch(url, opts);
    const t1 = performance.now();
    const text = await res.text();
    return { res, text, ms: Math.round(t1 - t0) };
  }

  function showResponse(res, text, ms) {
    const statusText = `${res.status} ${res.statusText} • ${ms}ms • content-type=${res.headers.get("content-type") || "?"}`;
    const first = text.slice(0, 200);
    $("raw").textContent = text;
    $("first200").textContent = first;

    // Quick tell for "HTML 200"
    if (first.includes("<!DOCTYPE html") || first.includes("<html") || first.includes("Google Apps Script")) {
      warnStatus(`Looks like HTML, not JSON → deployment/auth/URL/permissions likely wrong. (${statusText})`);
    } else if (!res.ok) {
      formatStatus(false, statusText);
    } else {
      formatStatus(true, statusText);
    }

    // try parse
    try {
      const j = JSON.parse(text);
      $("parsed").textContent = JSON.stringify(j, null, 2);
    } catch (e) {
      $("parsed").textContent = "(Not valid JSON)";
    }
  }

  function readInputs() {
    const endpoint = $("endpoint").value.trim();
    const token = $("token").value.trim();
    const kind = $("kind").value.trim();
    const key = $("key").value.trim();
    const cache = $("cacheMode").value;
    const postContentType = $("postContentType").value;
    const mode = $("mode").value;

    if (!endpoint) throw new Error("Endpoint URL is required.");
    if (!token) throw new Error("Token is required.");
    if (!kind) throw new Error("Kind is required.");
    if (!key) throw new Error("member_id/key is required.");

    return { endpoint, token, kind, key, cache, postContentType, mode };
  }

  // ---------- actions ----------
  async function ping() {
    clearOutput();
    const { endpoint, token, cache } = readInputs();
    const url = new URL(endpoint);
    url.searchParams.set("token", token);
    url.searchParams.set("kind", "ping");
    url.searchParams.set("_ts", Date.now().toString());

    const { res, text, ms } = await doFetchText(url.toString(), { method: "GET", cache });
    showResponse(res, text, ms);
  }

  async function writeRandom() {
    clearOutput();
    const { endpoint, token, kind, key, cache, postContentType, mode } = readInputs();

    // Use current payload textarea, but if empty, generate.
    if (!$("payload").value.trim()) setDefaultPayload();

    let payloadObj;
    try {
      payloadObj = JSON.parse($("payload").value);
    } catch (e) {
      throw new Error("Payload textarea is not valid JSON.");
    }

    // always refresh these so you can see a new write every click
    payloadObj.updated_at = nowIso();
    payloadObj.random = randHex(16);

    $("payload").value = JSON.stringify(payloadObj, null, 2);

    const body = {
      token,
      kind,
      member_id: key,
      payload: payloadObj,
      _client: "drive_store_debug.html",
      _sent_at: nowIso()
    };

    // Some Apps Script handlers prefer query string even for POST; optional.
    let postUrl = endpoint;
    if (mode === "both" || mode === "queryOnly") {
      // Keep it simple: pass token/kind/member_id in query too (doesn't hurt if script ignores it).
      const u = new URL(endpoint);
      u.searchParams.set("token", token);
      u.searchParams.set("kind", kind);
      u.searchParams.set("member_id", key);
      u.searchParams.set("_ts", Date.now().toString());
      postUrl = u.toString();
    }

    const { res, text, ms } = await doFetchText(postUrl, {
      method: "POST",
      cache,
      headers: { "Content-Type": postContentType },
      body: JSON.stringify(body)
    });

    showResponse(res, text, ms);
  }

  async function readBack() {
    clearOutput();
    const { endpoint, token, kind, key, cache } = readInputs();
    const url = buildGetUrl({ endpoint, token, kind, key });
    const { res, text, ms } = await doFetchText(url, { method: "GET", cache });
    showResponse(res, text, ms);
  }

  async function writeThenRead() {
    await writeRandom();
    // tiny pause helps if backend writes are slightly delayed
    await new Promise(r => setTimeout(r, 250));
    await readBack();
  }

  // ---------- wire up ----------
  $("btnPing").addEventListener("click", () => ping().catch(e => alert(e.message)));
  $("btnWrite").addEventListener("click", () => writeRandom().catch(e => alert(e.message)));
  $("btnRead").addEventListener("click", () => readBack().catch(e => alert(e.message)));
  $("btnWriteThenRead").addEventListener("click", () => writeThenRead().catch(e => alert(e.message)));
  $("btnClear").addEventListener("click", () => clearOutput());

  // Initialize
  setDefaultPayload();
</script>
</body>
</html>
