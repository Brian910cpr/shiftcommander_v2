<!-- supervisor.patched.v5.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ShiftCommander — Supervisor</title>
  <!-- SUPERVISOR PATCHED • 2026-02-08 22:34:36 -->
  <style>
    /* (UNCHANGED existing styles) */
  </style>
</head>
<body>
  <!-- (UNCHANGED existing HTML UI markup) -->

  <script>
  /******************************************************************
   * ShiftCommander — Supervisor (patched v5)
   * - Reads org_settings/members/units/seats/member_availability from adr-store
   * - Resolver now respects:
   *   - unit.seat_plan + seat credential_sets
   *   - org_settings.aliases.seat_id (seat_als_medic -> seat_als)
   *   - qualification normalization (case-insensitive)
   * - Does NOT relax rules: if no eligible candidate, seat remains OPEN
   ******************************************************************/

  /* ====== Existing code (UNCHANGED) ====== */
  const app = window.__SC_APP__ || (window.__SC_APP__ = {});
  app.state = app.state || { weekStart: null, runLog: [] };
  app.data  = app.data  || {};

  // ---- CONFIG ----
  const STORE_BASE = "https://store.adr-fr.org";

  // ---- DOM helpers / logging (existing) ----
  function $(sel){ return document.querySelector(sel); }
  function logLine(msg){
    const t = new Date();
    const hh = String(t.getHours()).padStart(2,"0");
    const mm = String(t.getMinutes()).padStart(2,"0");
    const ss = String(t.getSeconds()).padStart(2,"0");
    const line = `[${hh}:${mm}:${ss}] ${msg}`;
    app.state.runLog.push({ t: Date.now(), type:"info", msg });
    const el = $("#liveLog");
    if (el){
      el.value = (el.value ? (el.value + "\n") : "") + line;
      el.scrollTop = el.scrollHeight;
    }
  }

  function addDaysISO(dateISO, days){
    const [y,m,d] = dateISO.split("-").map(Number);
    const dt = new Date(Date.UTC(y, m-1, d));
    dt.setUTCDate(dt.getUTCDate() + Number(days||0));
    const yy = dt.getUTCFullYear();
    const mm = String(dt.getUTCMonth()+1).padStart(2,"0");
    const dd = String(dt.getUTCDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }

  function formatMemberName(m, { firstOnly=false } = {}){
    if (!m) return "";
    const first = (m.first_name || m.firstName || m.name || "").toString().trim();
    const last  = (m.last_name  || m.lastName  || "").toString().trim();
    if (firstOnly) return first || last || (m.member_id || m.memberId || "");
    const full = `${first} ${last}`.trim();
    return full || first || last || (m.member_id || m.memberId || "");
  }

  async function storeGet(kind, params={}){
    const url = new URL(STORE_BASE + "/sc/get");
    url.searchParams.set("kind", kind);
    for (const [k,v] of Object.entries(params||{})){
      if (v !== undefined && v !== null && v !== "") url.searchParams.set(k, String(v));
    }
    const r = await fetch(url.toString(), { method:"GET" });
    const data = await r.json().catch(()=>null);
    if (!r.ok) throw new Error(`storeGet ${kind} HTTP ${r.status}`);
    return data;
  }

  async function storePut(kind, value, { week=null, version=null, writeKey=null } = {}){
    const url = new URL(STORE_BASE + "/sc/put");
    const headers = { "content-type":"application/json" };
    if (writeKey) headers["x-adr-write-key"] = writeKey;
    const body = { kind, value };
    if (week) body.week = week;
    if (version) body.version = version;
    const r = await fetch(url.toString(), { method:"POST", headers, body: JSON.stringify(body) });
    const data = await r.json().catch(()=>null);
    return { ok: r.ok, status: r.status, data };
  }

  async function loadAllAvailabilities(members){
    // Pull member_availability per-member (legacy Drive layout via store read-through)
    const av = [];
    for (const m of (members||[])){
      const mid = String(m.member_id || m.memberId || "").trim();
      if (!mid) continue;
      try{
        const res = await storeGet("member_availability", { member_id: mid });
        const payload = res?.value ?? res?.payload ?? null;
        // payload may be blocks array or wrapper; normalize to array of blocks
        if (Array.isArray(payload)) av.push(...payload);
        else if (payload && Array.isArray(payload.blocks)) av.push(...payload.blocks);
      }catch(e){
        // ignore missing per-member files
      }
    }
    return av;
  }

  function computeHealthV1({ weekStartDate, schedule, org, members, avBy }){
    // (Existing health computation — unchanged)
    // Placeholder: keep your existing computeHealthV1 body here.
    // NOTE: This function exists in your file already; this stub will be replaced by your actual code.
    return {};
  }

  function setComputedSchedule(computed){
    app.data.computed_schedule = computed;
    // (Existing UI update logic — unchanged)
  }

  /* ====== Load inputs (existing, working with Drive->KV) ====== */
  async function loadInputs(){
    logLine("Loading inputs from store…");
    const [orgRes, membersRes, unitsRes, seatsRes] = await Promise.all([
      storeGet("org_settings"),
      storeGet("members"),
      storeGet("units"),
      storeGet("seats"),
    ]);

    // unwrap (store returns {value: ...})
    app.data.org_settings = orgRes.value ?? orgRes.payload ?? orgRes;
    app.data.members      = membersRes.value ?? membersRes.payload ?? [];
    app.data.units        = unitsRes.value ?? unitsRes.payload ?? [];
    app.data.seats        = seatsRes.value ?? seatsRes.payload ?? [];

    // availability is stored as per-member files
    const av = await loadAllAvailabilities(app.data.members);
    app.data.availability = av;

    logLine(`Loaded: members=${(app.data.members||[]).length}, availability=${(app.data.availability||[]).length}, units=${(app.data.units||[]).length}, seats=${(app.data.seats||[]).length}`);
  }

  /* ============================================================
   * ✅ PATCHED RESOLVER (v5)
   * ============================================================ */
  async function resolveWeek({ dryRun=false } = {}){
    // Deterministic, minimal resolver that respects:
    // - unit seat_plan (from /sc/get?kind=units)
    // - seat credential_sets (from /sc/get?kind=seats)
    // - per-member availability blocks (member_availability_*.json via store)
    // - no double-booking across AM/PM
    //
    // NOTE: This does NOT relax hard rules; if no eligible candidate exists, seat stays OPEN.

    if (!app.data.org_settings) return logLine("Missing org_settings; load inputs first.");
    if (!Array.isArray(app.data.members) || app.data.members.length===0) return logLine("Missing members; load inputs first.");

    const org = app.data.org_settings || {};
    const units = Array.isArray(app.data.units) ? app.data.units : [];
    const seats = Array.isArray(app.data.seats) ? app.data.seats : [];
    const avail = Array.isArray(app.data.availability) ? app.data.availability : [];
    const aliasSeat = (org.aliases && org.aliases.seat_id) ? org.aliases.seat_id : {};

    const seatById = new Map(seats.map(s => [String(s.id), s]));
    const normSeatId = (sid) => {
      const k = String(sid||"").trim();
      return aliasSeat[k] ? String(aliasSeat[k]) : k;
    };

    // Build case-insensitive qualification normalizer using org.qualification_policy.normalize_map if present.
    const normMap = (org.qualification_policy && org.qualification_policy.normalize_map) ? org.qualification_policy.normalize_map : {};
    const normMapLower = {};
    Object.keys(normMap).forEach(k => { normMapLower[String(k).toLowerCase()] = normMap[k]; });

    const normQual = (q) => {
      const raw = String(q||"").trim();
      if (!raw) return "";
      return normMapLower[raw.toLowerCase()] || raw; // keep if unknown
    };

    // Precompute member qualification sets (normalized)
    const members = app.data.members
      .filter(m => m && (m.active !== false))
      .map(m => {
        const qs = Array.isArray(m.qualifications) ? m.qualifications : [];
        const qSet = new Set(qs.map(normQual));
        return { ...m, _qSet: qSet };
      });

    // Availability helpers (expects blocks: {member_id,start_datetime,end_datetime,preference,is_partial})
    const blocksByMember = new Map();
    for (const b of avail){
      if (!b || !b.member_id) continue;
      const mid = String(b.member_id);
      if (!blocksByMember.has(mid)) blocksByMember.set(mid, []);
      blocksByMember.get(mid).push(b);
    }

    const dayStart = (org.availability && org.availability.shift_block_defaults && org.availability.shift_block_defaults.day_shift && org.availability.shift_block_defaults.day_shift.start) || "06:00";
    const dayEnd   = (org.availability && org.availability.shift_block_defaults && org.availability.shift_block_defaults.day_shift && org.availability.shift_block_defaults.day_shift.end)   || "18:00";
    const nightStart = (org.availability && org.availability.shift_block_defaults && org.availability.shift_block_defaults.night_shift && org.availability.shift_block_defaults.night_shift.start) || "18:00";
    const nightEnd   = (org.availability && org.availability.shift_block_defaults && org.availability.shift_block_defaults.night_shift && org.availability.shift_block_defaults.night_shift.end)   || "06:00";

    function shiftWindow(dateISO, shiftKey){
      const start = (shiftKey==="AM") ? `${dateISO}T${dayStart}:00` : `${dateISO}T${nightStart}:00`;
      let endDate = dateISO;
      if (shiftKey==="PM" && nightEnd < nightStart) endDate = addDaysISO(dateISO, 1);
      const end = (shiftKey==="AM") ? `${dateISO}T${dayEnd}:00` : `${endDate}T${nightEnd}:00`;
      return { start, end };
    }

    function hasAvailability(memberId, dateISO, shiftKey){
      const blocks = blocksByMember.get(String(memberId)) || [];
      if (!blocks.length) return { ok:false, score:-999, partial:false };
      const { start, end } = shiftWindow(dateISO, shiftKey);
      const s = Date.parse(start);
      const e = Date.parse(end);
      let best = null;

      for (const b of blocks){
        const bs = Date.parse(String(b.start_datetime));
        const be = Date.parse(String(b.end_datetime));
        const overlap = Math.max(0, Math.min(e, be) - Math.max(s, bs));
        if (overlap <= 0) continue;

        const full = (bs <= s && be >= e);
        const partial = !full;
        const pref = String(b.preference||"").toLowerCase();
        let score = 0;
        score += full ? 100 : 40;
        score += (pref==="preferred") ? 20 : (pref==="available") ? 10 : (pref==="avoid") ? -50 : 0;
        score += partial ? -30 : 0;

        if (!best || score > best.score) best = { ok:true, score, partial };
      }
      return best || { ok:false, score:-999, partial:false };
    }

    function memberMeetsSeat(member, seatDef){
      if (!seatDef) return true;
      const sets = Array.isArray(seatDef.credential_sets) ? seatDef.credential_sets : [];
      if (!sets.length) return true;

      for (const cs of sets){
        const any = Array.isArray(cs.requires_any) ? cs.requires_any.map(normQual) : [];
        const all = Array.isArray(cs.requires_all) ? cs.requires_all.map(normQual) : [];
        let okAll = true;
        for (const r of all){ if (r && !member._qSet.has(r)) { okAll=false; break; } }
        if (!okAll) continue;

        let okAny = true;
        if (any.length){
          okAny = any.some(r => r && member._qSet.has(r));
        }
        if (okAny) return true;
      }
      return false;
    }

    const defaultUnitId =
      (org.ops_defaults && Array.isArray(org.ops_defaults.default_unit_ids) && org.ops_defaults.default_unit_ids[0]) ||
      (units[0] && units[0].id) ||
      null;

    if (!defaultUnitId){
      logLine("No units available to schedule.");
      return;
    }

    const unitById = new Map(units.map(u => [String(u.id), u]));
    const unit = unitById.get(String(defaultUnitId)) || units[0];

    const planIdsRaw = Array.isArray(unit.seat_plan) ? unit.seat_plan : [];
    const planIds = planIdsRaw.map(normSeatId);

    function roleForSeat(seatId){
      const def = seatById.get(String(seatId));
      const label = String(def?.label || seatId).toLowerCase();
      if (label.includes("driver") || label.includes("operator")) return "operator";
      if (label.includes("3rd") || label.includes("third") || label.includes("rider")) return "third";
      return "attendant";
    }

    members.sort((a,b)=>String(a.member_id).localeCompare(String(b.member_id)));

    const assigned = new Set();

    const schedule = {};
    for (let d=0; d<7; d++){
      const dateISO = addDaysISO(app.state.weekStart, d);
      schedule[dateISO] = { AM:{}, PM:{} };

      for (const shiftKey of ["AM","PM"]){
        const slots = { attendant:"OPEN", operator:"OPEN", third:"OPEN" };

        for (const seatId of planIds){
          const seatDef = seatById.get(String(seatId));
          const role = roleForSeat(seatId);
          const required = !!seatDef?.required;

          if (!required && role==="third") continue; // optional default-off

          let best = null;
          for (const m of members){
            const mid = String(m.member_id);
            const key = `${dateISO}|${shiftKey}|${mid}`;
            if (assigned.has(key)) continue;

            if (!memberMeetsSeat(m, seatDef)) continue;

            const av = hasAvailability(mid, dateISO, shiftKey);
            if (!av.ok) continue;

            const cand = { m, score: av.score, partial: av.partial };
            if (!best) best = cand;
            else if (cand.score > best.score) best = cand;
            else if (cand.score === best.score && best.partial && !cand.partial) best = cand;
            else if (cand.score === best.score && cand.partial === best.partial &&
                     String(cand.m.member_id).localeCompare(String(best.m.member_id)) < 0) best = cand;
          }

          if (best){
            const chosen = best.m;
            const displayName = formatMemberName(chosen, { firstOnly: !!org.ui?.use_first_name_only });
            slots[role] = displayName;
            assigned.add(`${dateISO}|${shiftKey}|${chosen.member_id}`);
          } else if (required){
            // stays OPEN
          }
        }

        schedule[dateISO][shiftKey] = {
          attendant: slots.attendant,
          operator:  slots.operator,
          third:     slots.third
        };
      }
    }

    const health = computeHealthV1({ weekStartDate: app.state.weekStart, schedule, org, members: app.data.members, avBy: blocksByMember });

    const computed = {
      schedule,
      meta: {
        schema: "sc.schedule.v1",
        generated_at: new Date().toISOString(),
        week_start: app.state.weekStart,
        partial: false,
        reason: null
      },
      health,
      logs: app.state.runLog || []
    };

    setComputedSchedule(computed);

    if (dryRun){
      logLine("Dry run complete (not saved).");
      return;
    }

    logLine("✅ Resolver complete");
  }

  /* ====== Existing init/wiring (UNCHANGED) ====== */
  async function init(){
    // (your existing init code that sets weekStart, wires buttons, calls loadInputs/resolve/save/publish)
  }
  init();
  </script>
</body>
</html>
