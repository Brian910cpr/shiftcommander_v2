<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ShiftCommander — Member</title>
  <style>
    :root{
      --bg0:#070b14;
      --bg1:#0b1428;
      --card:#0c1a34;
      --card2:#0b1730;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --text:#e9f1ff;
      --muted:rgba(233,241,255,.72);
      --muted2:rgba(233,241,255,.50);
      --green:#26d07c;
      --blue:#5c8dff;
      --red:#ff5d5d;
      --clear:rgba(233,241,255,.26);
      --shadow:0 16px 50px rgba(0,0,0,.35);
      --r:16px;
      --r2:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background: radial-gradient(1100px 700px at 35% -20%, #163a86 0%, rgba(22,58,134,0) 55%),
                  radial-gradient(900px 600px at 90% 0%, #2a0e6e 0%, rgba(42,14,110,0) 60%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
    }

    .top{
      position:sticky;
      top:0;
      z-index:20;
      background: linear-gradient(180deg, rgba(5,8,16,.92), rgba(5,8,16,.55));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
    }
    .topInner{
      max-width: 1280px;
      margin: 0 auto;
      padding: 14px 14px 12px;
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .brand{
      font-weight:800;
      letter-spacing:.2px;
      margin-right:auto;
      white-space:nowrap;
    }
    .controls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      min-width: 320px;
    }
    .pill{
      background: rgba(255,255,255,.06);
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 9px 12px;
      display:flex;
      align-items:center;
      gap:10px;
      box-shadow: 0 8px 26px rgba(0,0,0,.18);
    }
    .pill label{font-size:12px; color:var(--muted2)}
    select, input[type="date"]{
      background: transparent;
      color: var(--text);
      border: 0;
      outline: 0;
      font-size: 14px;
    }
    option{color:#000}
    .btn{
      cursor:pointer;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 999px;
      padding: 9px 12px;
      font-weight: 700;
      box-shadow: 0 8px 26px rgba(0,0,0,.18);
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:active{transform: translateY(1px)}
    .btn:hover{background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.22)}
    .btn.secondary{font-weight:700; opacity:.95}

    .dot{
      width:10px; height:10px; border-radius:999px;
      background: var(--clear);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
      flex:0 0 auto;
    }
    .dot.ok{ background: var(--green); box-shadow: 0 0 0 3px rgba(38,208,124,.16) }
    .dot.warn{ background: #f4c542; box-shadow: 0 0 0 3px rgba(244,197,66,.16) }

    .wrap{
      max-width: 1280px;
      margin: 0 auto;
      padding: 16px 14px 18px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border: 1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .headline{
      display:flex;
      align-items:flex-start;
      gap:12px;
      flex-wrap:wrap;
    }
    .headline h2{
      margin:0;
      font-size: 16px;
      line-height:1.25;
      letter-spacing:.2px;
    }
    .headline .sub{
      margin:2px 0 0;
      font-size: 12px;
      color: var(--muted);
    }
    .headline .right{
      margin-left:auto;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .statusPill{
      display:flex;
      align-items:center;
      gap:10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
      padding: 8px 10px;
      min-height: 36px;
    }
    .statusPill .tiny{
      font-size:12px;
      color: var(--muted);
      max-width: 0;
      overflow:hidden;
      white-space:nowrap;
    }

    .gridWrap{
      margin-top: 14px;
      overflow-x:auto;
      border-radius: var(--r);
    }

    .cal{
      min-width: 980px;
      display:grid;
      grid-template-columns: 170px repeat(7, minmax(110px, 1fr));
      gap:10px;
      padding: 10px;
      background: rgba(0,0,0,.10);
      border: 1px solid var(--line);
      border-radius: var(--r);
    }
    .wkLabel{
      padding: 12px;
      border-radius: var(--r2);
      border: 1px solid var(--line);
      background: rgba(255,255,255,.035);
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
      min-height: 92px;
    }
    .wkTag{
      display:inline-flex;
      width:fit-content;
      align-items:center;
      gap:8px;
      font-size:12px;
      font-weight:800;
      letter-spacing:.3px;
      text-transform:uppercase;
      color: var(--muted);
    }
    .wkRange{ font-size: 12px; color: var(--muted); }
    .wkRange b{color:var(--text)}
    .hdrCell{
      padding: 10px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      font-weight: 900;
      letter-spacing:.3px;
      text-transform:uppercase;
      font-size: 12px;
      color: var(--text);
      text-align:center;
    }

    .dayCard{
      border-radius: var(--r2);
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      padding: 10px;
      min-height: 92px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .dayTop{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:10px;
    }
    .dayNum{ font-size: 26px; font-weight: 950; line-height:1; letter-spacing:.2px; }
    .dayMini{
      font-size: 11px;
      color: var(--muted2);
      letter-spacing:.2px;
      white-space:nowrap;
    }

    .shiftRow{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .shiftBtn{
      border-radius: 12px;
      padding: 10px 8px;
      border: 2px solid rgba(233,241,255,.12);
      background: rgba(255,255,255,.02);
      cursor:pointer;
      user-select:none;
      text-align:center;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      position: relative;
    }
    .shiftBtn:active{ transform: translateY(1px) }
    .shiftBtn.locked{ cursor: not-allowed; opacity:.55 }
    .shiftKey{ font-weight: 950; letter-spacing:.3px; font-size: 12px; }
    .shiftState{ font-size: 10px; color: var(--muted2); margin-top: 3px; letter-spacing:.2px; text-transform:uppercase; }

    .shiftBtn[data-state="preferred"]{ background: rgba(38,208,124,.22); }
    .shiftBtn[data-state="available"]{ background: rgba(92,141,255,.22); }
    .shiftBtn[data-state="nosched"]{ background: rgba(255,93,93,.22); }
    .shiftBtn[data-state="clear"]{ background: rgba(233,241,255,.06); border-style: dashed; }

    /* Heat border (Model A) */
    .shiftBtn[data-heat="need2"]{ border-color: rgba(38,208,124,.95); }
    .shiftBtn[data-heat="need1"]{ border-color: rgba(38,208,124,.55); }
    .shiftBtn[data-heat="neutral"]{ border-color: rgba(233,241,255,.18); }
    .shiftBtn[data-heat="crowd1"]{ border-color: rgba(255,168,54,.55); }
    .shiftBtn[data-heat="crowd2"]{ border-color: rgba(255,93,93,.92); }

    /* Pending marker (Published 30-min undo) */
    .shiftBtn[data-pending="1"]::after{
      content:"";
      position:absolute;
      right:6px; top:6px;
      width:8px; height:8px;
      border-radius:99px;
      background: rgba(255,168,54,.95);
      box-shadow: 0 0 0 3px rgba(255,168,54,.18);
    }

    /* History marker */
    .shiftBtn[data-state="worked"]{
      border-style: solid;
      border-color: rgba(233,241,255,.30);
      background: rgba(255,255,255,.03);
    }
    .shiftBtn[data-state="worked"] .shiftState{ color: rgba(233,241,255,.75) }

    .legend{
      margin-top: 12px;
      display:flex;
      flex-wrap:wrap;
      gap:10px 14px;
      align-items:center;
      color: var(--muted);
      font-size: 12px;
    }
    .legItem{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      cursor: help;
      user-select:none;
      white-space:nowrap;
    }
    .swatch{
      width: 10px; height: 10px; border-radius: 999px;
      background: rgba(233,241,255,.26);
      box-shadow: 0 0 0 3px rgba(255,255,255,.05);
    }
    .swatch.pref{ background: var(--green); box-shadow: 0 0 0 3px rgba(38,208,124,.16) }
    .swatch.av{ background: var(--blue); box-shadow: 0 0 0 3px rgba(92,141,255,.16) }
    .swatch.no{ background: var(--red); box-shadow: 0 0 0 3px rgba(255,93,93,.16) }
    .swatch.cl{ background: rgba(233,241,255,.26) }

    dialog{
      border:none;
      padding:0;
      border-radius: 18px;
      background: #0b1730;
      color: var(--text);
      width: min(720px, calc(100vw - 24px));
      box-shadow: 0 30px 80px rgba(0,0,0,.55);
    }
    dialog::backdrop{ background: rgba(0,0,0,.55) }
    .modalHead{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--line);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .modalHead h3{ margin:0; font-size: 15px }
    .modalBody{ padding: 14px }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
    .note{ font-size: 12px; color: var(--muted); line-height: 1.35 }
    .danger{ border-color: rgba(255,93,93,.55) }

    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform: translateX(-50%);
      background: rgba(10,16,30,.92);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      padding: 10px 12px;
      color: var(--text);
      font-weight: 800;
      font-size: 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.50);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index:999;
    }
    .toast.show{ opacity:1 }

    @media (max-width: 860px){
      .controls{ min-width: unset; width:100% }
      .cal{ min-width: 900px }
      .wkLabel{ min-height: 86px }
    }
  </style>
</head>
<body>
  <div class="top">
    <div class="topInner">
      <div class="brand">ShiftCommander — Member</div>

      <div class="controls">
        <div class="pill" title="Organization">
          <label>Org:</label>
          <span id="orgName" style="font-weight:900"></span>
        </div>

        <div class="pill" title="Select yourself">
          <label>Member:</label>
          <select id="memberSel"></select>
        </div>

        <button class="btn secondary" id="btnPrev">◀</button>
        <button class="btn secondary" id="btnThis">This Week</button>
        <button class="btn secondary" id="btnNext">▶</button>

        <div class="pill" title="Jump to a week start">
          <label>Week start:</label>
          <input id="weekPick" type="date"/>
        </div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="card">
      <div class="headline">
        <div>
          <h2>Set your availability</h2>
          <div class="sub">Tap AM/PM to cycle: Preferred → Available → Do not schedule → Clear.</div>
        </div>

        <div class="right">
          <div class="statusPill" id="savepill" title="Drive status">
            <span class="dot ok" id="driveDot"></span>
            <span class="tiny" id="driveTip">Saved</span>
          </div>
          <button class="btn" id="btnTools">Repeat / Tools</button>
        </div>
      </div>

      <div class="gridWrap">
        <div class="cal" id="cal"></div>
      </div>

      <div class="legend" aria-label="Availability legend">
        <span class="legItem" title="Preferred — You WANT this shift."><span class="swatch pref"></span> Preferred</span>
        <span class="legItem" title="Available — You CAN work this shift and will be considered if not filled by someone who PREFERS it (then weighted fairly)."><span class="swatch av"></span> Available</span>
        <span class="legItem" title="Do not schedule — You will not be considered for this shift."><span class="swatch no"></span> Do not schedule</span>
        <span class="legItem" title="Clear / unset — No preference stated. You may still be considered only if no one prefers or is available (and fairness allows it)."><span class="swatch cl"></span> Clear</span>
      </div>
    </div>
  </div>

  <dialog id="toolsDlg">
    <div class="modalHead">
      <h3>Repeat / Tools</h3>
      <div style="margin-left:auto"></div>
      <button class="btn secondary" id="btnCloseDlg">Close</button>
    </div>
    <div class="modalBody">
      <div class="note">
        Pick a <b>Pattern Week</b> (any week) and repeat it forward. The current work week may be restricted — your pattern doesn’t have to be.
      </div>

      <div style="height:10px"></div>

      <div class="row" style="align-items:center">
        <div class="pill" title="The week used as the source for repeats">
          <label>Pattern:</label>
          <span id="patternLabel" style="font-weight:900"></span>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="row">
        <button class="btn" id="copyPatternNext">Copy <b>Pattern</b> → next week</button>
        <button class="btn" id="copyPatternPublished">Copy <b>Pattern</b> → all <b>Published</b> weeks</button>
        <button class="btn danger" id="clearPatternWeek">Clear <b>Pattern</b> week</button>
      </div>

      <div style="height:14px"></div>

      <div style="border:1px solid var(--line); border-radius:16px; padding:12px; background: rgba(255,255,255,.03);">
        <div style="font-weight:900; margin-bottom:6px;">Repeat into Planning</div>
        <div class="note" style="margin-bottom:10px;">
          Repeat the <b>Pattern Week</b> every X weeks, starting in <b>Planning</b>, until the date you choose.
        </div>

        <div class="row" style="align-items:center">
          <label class="note">Every</label>
          <select id="repeatEvery" title="Repeat interval">
            <option value="2">2 weeks</option>
            <option value="4" selected>4 weeks</option>
          </select>

          <label class="note">until</label>
          <input type="date" id="repeatUntil" title="Last date to fill (inclusive)"/>

          <button class="btn" id="btnRepeatPlanning">Repeat → Planning</button>
        </div>
      </div>

      <div style="height:12px"></div>

      <label class="note" style="display:flex; align-items:center; gap:10px; cursor:pointer; user-select:none">
        <input type="checkbox" id="overwriteLocks" style="transform:scale(1.1)" />
        Overwrite future manual picks (ignore locks)
      </label>

      <div style="height:12px"></div>

      <div class="row" style="align-items:center; gap:10px">
        <span class="note">Published safety:</span>
        <button class="btn secondary" id="btnPostPending" title="Commit pending Published changes now (sync to Drive)">Post pending now</button>
        <button class="btn secondary" id="btnUndoPending" title="Undo any pending Published changes (revert locally)">Undo pending</button>
        <span class="note" id="pendingHint" style="margin-left:auto"></span>
      </div>

      <div style="height:10px"></div>
      <div class="note">
        By default, repeats won’t overwrite future dates you already touched. Check “Overwrite…” only when you mean it.
      </div>
    </div>
  </dialog>

  <div class="toast" id="toast"></div>

<script>
/* =========================
   Config
========================= */
const ORG_SETTINGS_URL = "/data/org_settings.json";
const MEMBERS_URL      = "/data/members.json";

/* Google Apps Script JSON store */
const STORE_URL = "https://script.google.com/macros/s/AKfycbyHus2_cZOds7sCMxNlGzcJq0nEEtdZwS7JwKdlV-h0o_hctGCz1OpwANZ3nHLgOIa-ug/exec";

/* Display window */
const WEEKS_SHOWN = 5; // THIS week + 4 ahead (Managed + Published + Planning)

/* Managed / Published definitions (your rulebook) */
const MANAGED_WEEKS = 3;    // THIS week + 2 more
const PUBLISHED_WEEKS = 3;  // next 3 after Managed

/* Published undo window */
const UNDO_MINUTES_PUBLISHED = 30;

/* =========================
   Helpers
========================= */
const $ = (id)=>document.getElementById(id);

function todayISO(){
  const t = new Date();
  return new Date(t.getFullYear(), t.getMonth(), t.getDate()).toISOString().slice(0,10);
}
function addDaysISO(dateISO, days){
  const d = new Date(dateISO + "T00:00:00");
  d.setDate(d.getDate()+days);
  return d.toISOString().slice(0,10);
}
function weekStartISO(anyDateISO){
  // week starts Thu (ADR cadence)
  const d = new Date(anyDateISO + "T00:00:00");
  const dow = d.getDay(); // 0 Sun..6 Sat
  const THU = 4;
  const delta = (dow - THU + 7) % 7;
  d.setDate(d.getDate() - delta);
  return d.toISOString().slice(0,10);
}
function daysBetweenISO(aISO, bISO){
  // whole-day difference b - a
  const a = new Date(aISO + "T00:00:00Z").getTime();
  const b = new Date(bISO + "T00:00:00Z").getTime();
  return Math.round((b - a) / 86400000);
}
function fmtMD(dateISO){
  const d = new Date(dateISO + "T00:00:00");
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return mm + "/" + dd;
}
function dayName(dateISO){
  return ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][new Date(dateISO+"T00:00:00").getDay()];
}
function isPast(dateISO){ return dateISO < todayISO(); }

function toast(msg){
  const t = $("toast");
  t.textContent = msg;
  t.classList.add("show");
  clearTimeout(toast._t);
  toast._t=setTimeout(()=>t.classList.remove("show"), 1600);
}

/* =========================
   Local + Remote State
========================= */
function lsKey(memberId){ return "sc_member_" + memberId; }
function lsMetaKey(memberId){ return "sc_member_meta_" + memberId; } // {dirty,lastPushISO,lastError,pending,locks,patternWeekStart}

function getLocal(memberId){
  try{ return JSON.parse(localStorage.getItem(lsKey(memberId)) || "{}"); }catch(e){ return {}; }
}
function setLocal(memberId, obj){
  localStorage.setItem(lsKey(memberId), JSON.stringify(obj));
}
function getMeta(memberId){
  try{ return JSON.parse(localStorage.getItem(lsMetaKey(memberId)) || "{}"); }catch(e){ return {}; }
}
function setMeta(memberId, meta){
  localStorage.setItem(lsMetaKey(memberId), JSON.stringify(meta));
}

async function storeGet(kind, memberId){
  const url = new URL(STORE_URL);
  url.searchParams.set("kind", kind);
  if(memberId) url.searchParams.set("memberId", memberId);
  const r = await fetch(url.toString(), { method:"GET", cache:"no-store" });
  if(!r.ok) throw new Error("store GET " + r.status);
  return await r.json();
}
async function storePut(kind, memberId, payload){
  const body = { kind, memberId, payload };
  const r = await fetch(STORE_URL, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify(body),
  });
  if(!r.ok) throw new Error("store POST " + r.status);
  return await r.json();
}

async function trySync(memberId){
  const meta = getMeta(memberId);
  if(!meta.dirty) return true;

  try{
    const payload = getLocal(memberId);
    await storePut("member", memberId, payload);
    meta.dirty = false;
    meta.lastError = "";
    meta.lastPushISO = new Date().toISOString();
    setMeta(memberId, meta);
    setDriveStatus(meta);
    return true;
  }catch(e){
    meta.lastError = String(e.message || e);
    setMeta(memberId, meta);
    setDriveStatus(meta);
    return false;
  }
}

/* Drive status UI:
   - dot stays GREEN (saved locally)
   - the tooltip communicates “synced / offline / pending / error”
*/
function setDriveStatus(meta){
  const tip = $("driveTip");
  const online = navigator.onLine !== false;

  let short = "Saved";
  if(meta && hasPending(meta)) short = "Pending";
  tip.textContent = short;

  const parts = [];
  parts.push("Saved locally on this device.");
  if(meta && hasPending(meta)){
    const ms = pendingRemainingMs(meta);
    parts.push(`Published changes pending (undo ${formatMinSec(ms)}).`);
    parts.push("Will sync to Drive after the undo window, or if you click ‘Post pending now’.");
  }else if(!online){
    parts.push("Offline: will sync to Drive when internet returns.");
  }else if(meta && meta.dirty){
    parts.push("Sync to Drive pending.");
  }else{
    parts.push("Synced to Drive.");
  }
  if(meta && meta.lastPushISO) parts.push("Last Drive sync: " + new Date(meta.lastPushISO).toLocaleString());
  if(meta && meta.lastError) parts.push("Drive sync issue: " + meta.lastError);
  $("savepill").title = parts.join(" ");
}

/* =========================
   History (optional)
========================= */
const historyCache = new Map();

async function loadHistoryMonth(yyyyMM){
  if(historyCache.has(yyyyMM)) return historyCache.get(yyyyMM);
  try{
    const r = await fetch(`/data/history/${yyyyMM}.normalized.json`, { cache:"no-store" });
    if(!r.ok) throw new Error("history " + r.status);
    const j = await r.json();
    historyCache.set(yyyyMM, j);
    return j;
  }catch(e){
    historyCache.set(yyyyMM, null);
    return null;
  }
}
function memberWorked(historyMonth, dateISO, half, memberId){
  if(!historyMonth || !historyMonth.days || !historyMonth.days[dateISO]) return false;
  const d = historyMonth.days[dateISO];
  const obj = d[half];
  if(!obj) return false;
  for(const k of Object.keys(obj)){
    const v = obj[k];
    if(v && typeof v === "object" && v.member_id && String(v.member_id) === String(memberId)){
      return true;
    }
  }
  return false;
}

/* =========================
   Availability Model
========================= */
const cycle = ["preferred","available","nosched","clear"];
const stateLabelTiny = {
  preferred:"Preferred",
  available:"Available",
  nosched:"Do not schedule",
  clear:"Clear",
  worked:"Worked"
};
function getStateFor(memberState, dateISO, half){
  return (memberState?.[dateISO]?.[half]) || "clear";
}
function setStateFor(memberState, dateISO, half, val){
  if(!memberState[dateISO]) memberState[dateISO] = {};
  memberState[dateISO][half] = val;
}

/* =========================
   Managed / Published / Planning
========================= */
let managedWeekStart = weekStartISO(todayISO());

function weekRangeLabel(startISO){
  const end = addDaysISO(startISO, 6);
  return `${fmtMD(startISO)} – ${fmtMD(end)}`;
}

function weekTag(startISO){
  const t = todayISO();
  const end = addDaysISO(startISO, 6);

  if(end < t) return "Past";

  const diffDays = daysBetweenISO(managedWeekStart, startISO);
  const w = Math.floor(diffDays / 7); // 0 = current week

  if(w >= 0 && w < MANAGED_WEEKS) return "Managed";
  if(w >= MANAGED_WEEKS && w < (MANAGED_WEEKS + PUBLISHED_WEEKS)) return "Published";
  return "Planning";
}

function stageForDateISO(dateISO){
  return weekTag(weekStartISO(dateISO));
}

/* =========================
   Published Undo (30 min)
========================= */
function getPendingMap(meta){
  if(!meta.pending || typeof meta.pending !== "object") meta.pending = {};
  return meta.pending;
}
function markPending(meta, dateISO, half, prevVal, nextVal){
  const key = `${dateISO}|${half}`;
  const now = Date.now();
  const expiresAt = now + UNDO_MINUTES_PUBLISHED*60*1000;
  const pending = getPendingMap(meta);
  if(!pending[key]){
    pending[key] = { prev: prevVal, next: nextVal, createdAt: now, expiresAt };
  }else{
    pending[key].next = nextVal;
    pending[key].expiresAt = expiresAt;
  }
  return key;
}
function pendingRemainingMs(meta){
  const pending = getPendingMap(meta);
  let min = Infinity;
  for(const k in pending){
    const ms = (pending[k]?.expiresAt || 0) - Date.now();
    if(ms > 0 && ms < min) min = ms;
  }
  return (min===Infinity) ? 0 : min;
}
function formatMinSec(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const m = Math.floor(s/60);
  const r = s%60;
  return m>0 ? `${m}m ${String(r).padStart(2,'0')}s` : `${r}s`;
}
function hasPending(meta){
  const pending = getPendingMap(meta);
  return Object.keys(pending).length > 0;
}
async function flushExpiredPending(memberId){
  const meta = getMeta(memberId);
  const pending = getPendingMap(meta);
  let changed = false;

  for(const key of Object.keys(pending)){
    const item = pending[key];
    if(!item) { delete pending[key]; changed = true; continue; }
    if(Date.now() >= (item.expiresAt || 0)){
      delete pending[key];
      changed = true;
    }
  }
  if(changed){
    setMeta(memberId, meta);
    await trySync(memberId);
  }
}
function applyPendingMarkers(){
  const meta = getMeta(memberId);
  const pending = getPendingMap(meta);
  document.querySelectorAll(".shiftBtn").forEach(btn=>{
    const k = `${btn.dataset.date}|${btn.dataset.half}`;
    btn.dataset.pending = pending[k] ? "1" : "0";
  });
}

/* =========================
   Locks + Pattern Week
========================= */
function getLocks(memberId){
  const meta = getMeta(memberId);
  return meta.locks || {};
}
function setLocked(memberId, dateISO){
  const meta = getMeta(memberId);
  meta.locks = meta.locks || {};
  meta.locks[dateISO] = true;
  setMeta(memberId, meta);
}
function getPatternWeek(memberId){
  const meta = getMeta(memberId);
  if(meta.patternWeekStart) return meta.patternWeekStart;
  return addDaysISO(managedWeekStart, 7); // default: first Published week
}
function planningWeekStart(){
  return addDaysISO(managedWeekStart, 7*(MANAGED_WEEKS + PUBLISHED_WEEKS));
}

/* =========================
   Heat Map (Model A)
========================= */
let HEAT = { ready:false, byKey:{}, eligibleCount:0, loadedAt:0, lastError:"" };

function heatKey(dateISO, half){ return `${dateISO}|${half}`; }
function eligibleMembers(){
  return (members || []).filter(m => m && m.active !== false);
}
function classifyHeat(ratio, E, R){
  if(E < 4){
    if(R <= 0) return "need2";
    if(R === 1) return "need1";
    if(R === 2) return "neutral";
    return "crowd2";
  }
  if(ratio < 0.10) return "need2";
  if(ratio < 0.25) return "need1";
  if(ratio < 0.50) return "neutral";
  if(ratio < 0.75) return "crowd1";
  return "crowd2";
}
async function loadHeat(){
  try{
    const E = eligibleMembers().length;
    HEAT.eligibleCount = E;
    if(E === 0){ HEAT.ready = true; HEAT.byKey = {}; return; }

    const all = await storeGet("member");
    const payloads = [];

    if(Array.isArray(all)){
      for(const item of all){
        if(item && item.payload) payloads.push(item.payload);
      }
    }else if(all && typeof all === "object"){
      if(Array.isArray(all.items)){
        for(const item of all.items){
          if(item && item.payload) payloads.push(item.payload);
        }
      }else{
        for(const k of Object.keys(all)){
          const item = all[k];
          if(item && item.payload) payloads.push(item.payload);
        }
      }
    }

    const counts = {};
    for(const st of payloads){
      if(!st || typeof st !== "object") continue;
      for(const dateISO of Object.keys(st)){
        const day = st[dateISO];
        if(!day || typeof day !== "object") continue;
        for(const half of Object.keys(day)){
          if(day[half] === "preferred"){
            const k = heatKey(dateISO, half);
            counts[k] = (counts[k] || 0) + 1;
          }
        }
      }
    }

    const byKey = {};
    for(const k of Object.keys(counts)){
      const R = counts[k] || 0;
      const ratio = R / E;
      byKey[k] = { R, E, ratio, level: classifyHeat(ratio, E, R) };
    }

    HEAT.byKey = byKey;
    HEAT.ready = true;
    HEAT.loadedAt = Date.now();
    HEAT.lastError = "";
  }catch(e){
    console.warn("Heat load failed:", e);
    HEAT.ready = false;
    HEAT.lastError = String(e?.message || e);
  }
}
function applyHeatToUI(){
  const cal = $("cal");
  if(!cal) return;
  cal.querySelectorAll(".shiftBtn").forEach(btn=>{
    const dateISO = btn.dataset.date;
    const half = btn.dataset.half;
    if(!dateISO || !half) return;

    const stage = stageForDateISO(dateISO);
    if(stage !== "Published" && stage !== "Planning"){
      btn.dataset.heat = "neutral";
      return;
    }

    const k = heatKey(dateISO, half);
    const h = HEAT.byKey[k];
    btn.dataset.heat = h ? h.level : "need2";
    if(h){
      const pct = Math.round(h.ratio*100);
      btn.title = btn.title + `\nPopularity: ${h.R}/${h.E} eligible prefer (${pct}%).`;
    }else if(HEAT.eligibleCount){
      btn.title = btn.title + `\nPopularity: 0/${HEAT.eligibleCount} eligible prefer (0%).`;
    }
  });
}

/* =========================
   Render
========================= */
let orgSettings = null;
let members = [];
let memberId = null;
let editWeekStart = weekStartISO(todayISO());

let patternWeekStart = null;
let memberState = {};
let locks = {};
let suppressEditPast = true;

function buildHeaderRow(container){
  const corner = document.createElement("div");
  corner.className = "hdrCell";
  corner.style.opacity = ".85";
  corner.textContent = "Week";
  container.appendChild(corner);

  for(let i=0;i<7;i++){
    const dateISO = addDaysISO(editWeekStart, i);
    const h = document.createElement("div");
    h.className = "hdrCell";
    h.textContent = dayName(dateISO);
    container.appendChild(h);
  }
}

function buildWeekRow(container, startISO){
  const tag = weekTag(startISO);

  const label = document.createElement("div");
  label.className = "wkLabel";

  const t = document.createElement("div");
  t.className = "wkTag";
  const dotClass = (tag==="Managed" || tag==="Published") ? "ok" : "warn";
  const isPattern = (startISO === patternWeekStart);

  t.innerHTML = `<span class="dot ${dotClass}"></span>${tag}${isPattern ? ' <span style="margin-left:6px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.04); font-size:11px; font-weight:950;">PATTERN</span>' : ''}`;

  const r = document.createElement("div");
  r.className = "wkRange";
  r.innerHTML = `<b>${weekRangeLabel(startISO)}</b>`;

  const pb = document.createElement("button");
  pb.className = "btn secondary";
  pb.style.padding = "7px 10px";
  pb.style.borderRadius = "999px";
  pb.style.fontSize = "12px";
  pb.textContent = "Set Pattern";
  pb.title = "Use this week as your repeating Pattern Week";
  pb.addEventListener("click", (ev)=>{ ev.stopPropagation(); setPatternWeek(startISO); });

  label.appendChild(t);
  label.appendChild(r);
  label.appendChild(pb);
  container.appendChild(label);

  for(let i=0;i<7;i++){
    const dateISO = addDaysISO(startISO, i);
    const day = document.createElement("div");
    day.className = "dayCard";

    const top = document.createElement("div");
    top.className = "dayTop";
    const num = document.createElement("div");
    num.className = "dayNum";
    num.textContent = String(new Date(dateISO+"T00:00:00").getDate());
    const mini = document.createElement("div");
    mini.className = "dayMini";
    mini.textContent = fmtMD(dateISO);
    top.appendChild(num);
    top.appendChild(mini);

    const row = document.createElement("div");
    row.className = "shiftRow";

    const isLockedPast = isPast(dateISO) && suppressEditPast;
    const editable = !isLockedPast;

    const monthKey = dateISO.slice(0,7);
    const hist = historyCache.get(monthKey) || null;

    for(const half of ["AM","PM"]){
      const btn = document.createElement("div");
      btn.className = "shiftBtn";
      btn.dataset.date = dateISO;
      btn.dataset.half = half;

      let state = getStateFor(memberState, dateISO, half);
      if(isPast(dateISO)){
        if(hist && memberWorked(hist, dateISO, half, memberId)) state = "worked";
      }

      btn.dataset.state = state;
      btn.dataset.heat = "neutral";
      btn.dataset.pending = "0";
      btn.title = `${dayName(dateISO)} ${fmtMD(dateISO)} ${half} — ${stateLabelTiny[state] || state}`;

      if(!editable || state==="worked") btn.classList.add("locked");

      const key = document.createElement("div");
      key.className = "shiftKey";
      key.textContent = half;

      const st = document.createElement("div");
      st.className = "shiftState";
      st.textContent = state==="clear" ? "" : (state==="nosched" ? "NO" : (state==="preferred" ? "PREF" : (state==="available" ? "AVL" : state.toUpperCase())));
      btn.appendChild(key);
      btn.appendChild(st);

      btn.addEventListener("click", async ()=>{
        if(!editable) return;
        if(btn.dataset.state === "worked") return;

        const cur = btn.dataset.state || "clear";
        const nxt = cycle[(cycle.indexOf(cur)+1) % cycle.length];

        btn.dataset.state = nxt;
        btn.title = `${dayName(dateISO)} ${fmtMD(dateISO)} ${half} — ${stateLabelTiny[nxt]}`;
        st.textContent = nxt==="clear" ? "" : (nxt==="nosched" ? "NO" : (nxt==="preferred" ? "PREF" : "AVL"));

        setStateFor(memberState, dateISO, half, nxt);
        setLocal(memberId, memberState);
        setLocked(memberId, dateISO);

        const meta = getMeta(memberId);
        meta.dirty = true;

        const stage = stageForDateISO(dateISO);

        if(stage === "Published"){
          markPending(meta, dateISO, half, cur, nxt);
          setMeta(memberId, meta);
          setDriveStatus(meta);
          applyPendingMarkers();
          updatePendingHint();
          toast("Pending (undo 30m)");
          return;
        }

        setMeta(memberId, meta);
        setDriveStatus(meta);

        const ok = await trySync(memberId);
        if(ok) toast("Saved");
      });

      row.appendChild(btn);
    }

    day.appendChild(top);
    day.appendChild(row);
    container.appendChild(day);
  }
}

async function render(){
  const cal = $("cal");
  cal.innerHTML = "";
  buildHeaderRow(cal);

  const months = new Set();
  for(let w=0; w<WEEKS_SHOWN; w++){
    const ws = addDaysISO(editWeekStart, w*7);
    for(let i=0;i<7;i++) months.add(addDaysISO(ws,i).slice(0,7));
  }
  await Promise.all([...months].map(loadHistoryMonth));

  for(let w=0; w<WEEKS_SHOWN; w++){
    buildWeekRow(cal, addDaysISO(editWeekStart, w*7));
  }

  if(HEAT.ready) applyHeatToUI();
  if(memberId) applyPendingMarkers();
}

/* =========================
   Repeat / Tools
========================= */
function updatePatternLabel(){
  $("patternLabel").textContent = weekRangeLabel(patternWeekStart);
}
function setPatternWeek(startISO){
  patternWeekStart = startISO;
  const meta = getMeta(memberId);
  meta.patternWeekStart = startISO;
  setMeta(memberId, meta);
  updatePatternLabel();
  render();
}
function updatePendingHint(){
  const meta = getMeta(memberId);
  const p = getPendingMap(meta);
  const keys = Object.keys(p);
  if(keys.length === 0){ $("pendingHint").textContent = ""; return; }
  const ms = pendingRemainingMs(meta);
  $("pendingHint").textContent = `${keys.length} pending • undo ${formatMinSec(ms)}`;
}

function copyWeekPattern(srcWeekStartISO, dstWeekStartISO, respectLocks=true){
  for(let i=0;i<7;i++){
    const srcDay = addDaysISO(srcWeekStartISO, i);
    const dstDay = addDaysISO(dstWeekStartISO, i);
    if(respectLocks && locks[dstDay]) continue;
    for(const half of ["AM","PM"]){
      const v = getStateFor(memberState, srcDay, half);
      setStateFor(memberState, dstDay, half, v);
    }
  }
}

async function persistAfterBulkEdit(){
  setLocal(memberId, memberState);
  const meta = getMeta(memberId);
  meta.dirty = true;
  setMeta(memberId, meta);
  setDriveStatus(meta);
  await render();
  const ok = await trySync(memberId);
  if(ok) toast("Saved");
}

$("btnTools").addEventListener("click", ()=>{
  updatePatternLabel();
  updatePendingHint();
  $("toolsDlg").showModal();
});
$("btnCloseDlg").addEventListener("click", ()=> $("toolsDlg").close());

$("copyPatternNext").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks").checked === true;
  copyWeekPattern(patternWeekStart, addDaysISO(patternWeekStart, 7), !overwrite);
  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

$("copyPatternPublished").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks").checked === true;
  const pubStart = addDaysISO(managedWeekStart, 7*MANAGED_WEEKS);
  for(let w=0; w<PUBLISHED_WEEKS; w++){
    copyWeekPattern(patternWeekStart, addDaysISO(pubStart, w*7), !overwrite);
  }
  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

$("clearPatternWeek").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks").checked === true;
  for(let i=0;i<7;i++){
    const day = addDaysISO(patternWeekStart, i);
    if(!overwrite && locks[day]) continue;
    for(const half of ["AM","PM"]){
      setStateFor(memberState, day, half, "clear");
    }
  }
  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

$("btnRepeatPlanning").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks").checked === true;
  const every = parseInt($("repeatEvery").value || "4", 10);
  const until = $("repeatUntil").value || "";
  if(!until){ toast("Pick an 'until' date"); return; }

  const untilWeek = weekStartISO(until);
  const startPlanning = planningWeekStart();

  for(let wStart = patternWeekStart; wStart <= untilWeek; ){
    wStart = addDaysISO(wStart, every*7);
    if(wStart > untilWeek) break;
    if(addDaysISO(wStart, 6) < todayISO()) continue;
    if(wStart < startPlanning) continue;
    copyWeekPattern(patternWeekStart, wStart, !overwrite);
  }

  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

$("btnPostPending").addEventListener("click", async ()=>{
  const meta = getMeta(memberId);
  const keys = Object.keys(getPendingMap(meta));
  if(keys.length === 0){ toast("No pending changes"); return; }
  meta.pending = {};
  setMeta(memberId, meta);
  setDriveStatus(meta);
  const ok = await trySync(memberId);
  await render();
  toast(ok ? "Posted" : "Posted (local), sync pending");
  $("toolsDlg").close();
});

$("btnUndoPending").addEventListener("click", async ()=>{
  const meta = getMeta(memberId);
  const p = getPendingMap(meta);
  const keys = Object.keys(p);
  if(keys.length === 0){ toast("No pending changes"); return; }

  for(const k of keys){
    const [dateISO, half] = k.split("|");
    const item = p[k];
    if(!dateISO || !half || !item) continue;
    setStateFor(memberState, dateISO, half, item.prev || "clear");
  }
  meta.pending = {};
  setLocal(memberId, memberState);
  setMeta(memberId, meta);
  setDriveStatus(meta);
  await render();
  toast("Undone");
  $("toolsDlg").close();
});

/* =========================
   Boot
========================= */
async function loadRequired(){
  const [orgR, memR] = await Promise.all([
    fetch(ORG_SETTINGS_URL, {cache:"no-store"}),
    fetch(MEMBERS_URL, {cache:"no-store"})
  ]);
  if(!orgR.ok) throw new Error("Fetch failed " + orgR.status + ": " + ORG_SETTINGS_URL);
  if(!memR.ok) throw new Error("Fetch failed " + memR.status + ": " + MEMBERS_URL);

  orgSettings = await orgR.json();
  const memJson = await memR.json();

  let rawMembers = memJson;
  if(Array.isArray(memJson)) rawMembers = memJson;
  else if(memJson && Array.isArray(memJson.members)) rawMembers = memJson.members;
  else throw new Error("members is not iterable (unexpected members.json shape)");

  members = rawMembers.map(m => ({
    id: String(m.id ?? m.member_id ?? ""),
    first: (m.first ?? m.first_name ?? "").trim(),
    last: (m.last ?? m.last_name ?? "").trim(),
    active: (m.active !== false),
    _raw: m
  })).filter(m => m.id);

  const orgName = orgSettings?.org_name || orgSettings?.org?.name || "Org";
  $("orgName").textContent = orgName;

  const sel = $("memberSel");
  sel.innerHTML = "";
  for(const m of members){
    const opt = document.createElement("option");
    opt.value = m.id;
    opt.textContent = `${m.last || ""}, ${m.first || ""} #${m.id}`;
    sel.appendChild(opt);
  }
  memberId = String(members?.[0]?.id || "");
  sel.value = memberId;
}

async function loadMember(){
  managedWeekStart = weekStartISO(todayISO());

  locks = getLocks(memberId);

  memberState = getLocal(memberId) || {};
  let meta = getMeta(memberId);

  patternWeekStart = meta.patternWeekStart || getPatternWeek(memberId);

  setDriveStatus(meta);

  try{
    const remote = await storeGet("member", memberId);
    if(remote && remote.payload){
      if(!meta.dirty){
        memberState = remote.payload;
        setLocal(memberId, memberState);
      }
      meta.lastError = "";
      setMeta(memberId, meta);
      setDriveStatus(meta);
    }
  }catch(e){
    meta.lastError = String(e.message || e);
    setMeta(memberId, meta);
    setDriveStatus(meta);
  }

  await trySync(memberId);

  updatePatternLabel();
  await render();
}

function setEditWeekStart(newStartISO){
  editWeekStart = weekStartISO(newStartISO);
  $("weekPick").value = editWeekStart;
  render();
}

$("memberSel").addEventListener("change", async (e)=>{
  memberId = String(e.target.value);
  await loadMember();
});

$("btnPrev").addEventListener("click", ()=> setEditWeekStart(addDaysISO(editWeekStart, -7)));
$("btnNext").addEventListener("click", ()=> setEditWeekStart(addDaysISO(editWeekStart, 7)));
$("btnThis").addEventListener("click", ()=> setEditWeekStart(todayISO()));
$("weekPick").addEventListener("change", (e)=>{ if(e.target.value) setEditWeekStart(e.target.value); });

window.addEventListener("online", ()=> { if(memberId) trySync(memberId); });
window.addEventListener("offline", ()=> { if(memberId) setDriveStatus(getMeta(memberId)); });

(async function boot(){
  try{
    await loadRequired();
    setEditWeekStart(todayISO());

    const ru = $("repeatUntil");
    if(ru){
      const d = new Date();
      d.setMonth(d.getMonth()+6);
      ru.value = d.toISOString().slice(0,10);
    }

    await loadMember();

    loadHeat().then(()=>{ if(HEAT.ready) applyHeatToUI(); }).catch(()=>{});

    // Pending timer + auto flush
    setInterval(async ()=>{
      if(!memberId) return;
      const meta = getMeta(memberId);
      if(hasPending(meta)){
        updatePendingHint();
        await flushExpiredPending(memberId);
        applyPendingMarkers();
        setDriveStatus(getMeta(memberId));
      }
    }, 15000);

  }catch(e){
    alert("Member page failed to load required data:\n\n" + (e.message || e));
    console.error(e);
  }
})();
</script>
</body>
</html>
