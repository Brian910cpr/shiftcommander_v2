<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ShiftCommander — Member Scheduling</title>

<style>
:root{
  --bg:#0b1020;
  --card:#111a33;
  --card2:rgba(255,255,255,.045);
  --line:rgba(255,255,255,.12);
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.55);

  --pref:#2bd27e;
  --avail:#5c8dff;
  --no:#ff5d5d;
  --clear: rgba(255,255,255,.18);

  --warn:#f4c542;
}

*{box-sizing:border-box}
html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui}

/* Top header */
header{
  position:sticky;top:0;z-index:10;
  background:linear-gradient(180deg,#050814,#050814cc);
  border-bottom:1px solid var(--line);
  padding:10px 14px;
  display:flex;gap:12px;align-items:center;flex-wrap:wrap;
}

.pill{
  background:rgba(255,255,255,.06);
  border:1px solid var(--line);
  border-radius:999px;
  padding:6px 10px;
  font-size:13px;
  white-space:nowrap;
  flex-shrink:0;
}

select{
  min-width:240px;
  font-size:14px;
  background:rgba(255,255,255,.04);
  color:var(--text);
  border:1px solid var(--line);
  border-radius:10px;
  padding:6px 8px;
}

/* Save pill (quiet) */
.savePill{
  display:flex; align-items:center; gap:10px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  border-radius:999px;
  padding:6px 10px;
  min-height:34px;
  cursor: default;
  margin-left:auto;
  max-width: 180px;
}
.savePill .tiny{
  font-size:12px;
  color: rgba(234,241,255,.70);
  min-width:0;
  overflow:hidden;
  white-space:nowrap;
  text-overflow:ellipsis;
  line-height:1;
}
.dot{
  width:10px; height:10px; border-radius:999px;
  background: rgba(233,241,255,.26);
  box-shadow: 0 0 0 3px rgba(255,255,255,.06);
}
.dot.ok{ background:#2bd27e; box-shadow: 0 0 0 3px rgba(43,210,126,.16); }
.dot.warn{ background:var(--warn); box-shadow: 0 0 0 3px rgba(244,197,66,.16); }

/* Tabs */
.tabbar{
  display:flex;
  gap:8px;
  padding:10px 12px 0;
}
.tabbtn{
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  color: var(--text);
  padding: 8px 10px;
  border-radius: 12px;
  font-weight: 900;
  font-size: 12px;
  cursor: pointer;
  user-select:none;
}
.tabbtn:hover{border-color:rgba(255,255,255,.22)}
.tabbtn.active{
  background: rgba(92,141,255,.18);
  border-color: rgba(92,141,255,.35);
}
main{ padding:12px; }
.tab{ display:none; }
.tab.active{ display:block; }

/* Panels */
.panel{
  background: var(--card2);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  padding: 10px;
  margin-bottom: 12px;
}
.panelTitle{
  font-weight: 900;
  font-size: 13px;
  margin-bottom: 6px;
}
.panelHint{
  color: var(--muted);
  font-size: 12px;
  line-height: 1.25;
}

/* Toggle row */
.togRow{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
  margin-top:8px;
}
.toggle{
  display:flex;
  gap:8px;
  align-items:center;
  padding:8px 10px;
  border-radius: 12px;
  background: rgba(255,255,255,.04);
  border:1px solid rgba(255,255,255,.10);
}
.toggle input{ transform: scale(1.1); }
.toggle .lbl{ font-weight: 900; font-size: 12px; }
.toggle .sub{ font-size: 11px; color: var(--muted); margin-top:2px; line-height:1.2; }
.toggle .col{ display:flex; flex-direction:column; }

/* Bulk tools */
.bulkGrid{
  margin-top:8px;
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:flex-end;
}
.bulkField{display:flex;flex-direction:column;gap:4px}
.bulkField span{font-size:11px;color:var(--muted)}
.bulkField select, .bulkField input{
  background: rgba(255,255,255,.04);
  color: var(--text);
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 10px;
  padding: 6px 8px;
  min-width: 160px;
}
.bulkBtns{display:flex;gap:8px;align-items:flex-end;flex-wrap:wrap}
.bbtn{
  border:1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.04);
  color: var(--text);
  padding: 7px 10px;
  border-radius: 10px;
  font-weight: 900;
  font-size: 12px;
  cursor: pointer;
}
.bbtn:hover{border-color:rgba(255,255,255,.25)}
.bbtn.primary{background: rgba(92,141,255,.18); border-color: rgba(92,141,255,.35)}
.bbtn.danger{background: rgba(255,93,93,.16); border-color: rgba(255,93,93,.30)}
.bbtn.ghost{background: rgba(255,255,255,.03); border-color: rgba(255,255,255,.12)}

  .day{ position:relative; }
  .bar.committed{
    outline:3px solid rgba(255,255,255,.85);
    outline-offset:-3px;
    box-shadow: 0 0 0 2px rgba(92,141,255,.25), 0 0 10px rgba(92,141,255,.18);
  }
/* Calendar month layout */
.monthRow{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(320px,1fr));
  gap:12px;
  margin-bottom:12px;
}
.month{
  background:var(--card);
  border:1px solid var(--line);
  border-radius:14px;
  padding:8px;
}
.month h3{
  margin:2px 0 6px;
  font-size:14px;
  font-weight:900;
  text-align:center;
}
.dow{
  display:grid;
  grid-template-columns:repeat(7,1fr);
  font-size:10px;
  color:var(--muted);
  text-align:center;
  margin-bottom:4px;
}
.grid{
  display:grid;
  grid-template-columns:repeat(7,1fr);
  gap:4px;
  align-content:start;
}

/* Day cells */
.day{
  height:30px;
  border:1px solid var(--line);
  border-radius:10px;
  padding:3px 4px;
  display:flex;
  flex-direction:row;
  align-items:center;
  gap:6px;
}
.day.blank{border:none;background:none}
.day.past{opacity:.35;pointer-events:none}

/* day number */
.dayNum{
  width:16px;
  text-align:right;
  font-size:11px;
  font-weight:900;
  line-height:1;
  cursor:pointer;
}

/* pill stack */
.bars{
  display:flex;
  flex-direction:column;
  gap:3px;
  align-items:flex-start;
}
.bar{
  width:34px;
  height:10px;
  border-radius:999px;
  cursor:pointer;
  background: var(--clear);
  border: 1px solid rgba(255,255,255,.25);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:9px;
  font-weight:900;
  line-height:1;
  letter-spacing:0.2px;
  color: rgba(255,255,255,.80);
  user-select:none;
}
.bar::after{ content: attr(data-label); }
.bar.pref{ background:var(--pref); border-color:var(--pref); color: rgba(0,0,0,.70); }
.bar.avail{ background:var(--avail); border-color:var(--avail); color: rgba(0,0,0,.70); }
.bar.no{ background:var(--no); border-color:var(--no); color: rgba(0,0,0,.70); }
.bar:not(.pref):not(.avail):not(.no){ opacity:.75; }

/* Preferences tab list */
.searchRow{
  display:flex; gap:10px; align-items:center; flex-wrap:wrap;
  margin: 8px 0 10px;
}
.searchRow input{
  background: rgba(255,255,255,.04);
  color: var(--text);
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 10px;
  padding: 7px 10px;
  min-width: 260px;
}
.roster{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
  gap:8px;
}
.person{
  display:flex;
  gap:8px;
  align-items:center;
  padding:8px 10px;
  border-radius: 12px;
  background: rgba(255,255,255,.04);
  border: 1px solid rgba(255,255,255,.10);
}
.person .name{ font-weight: 900; font-size: 12px; }
.person .meta{ font-size: 11px; color: var(--muted); }

/* Impact tab */
.weekBlock{
  border:1px solid rgba(255,255,255,.12);
  border-radius: 14px;
  padding: 10px;
  background: rgba(255,255,255,.03);
  margin-bottom: 10px;
  position: relative;
}
.weekTag{
  display:inline-flex;
  gap:8px;
  align-items:center;
  font-weight: 900;
  font-size: 12px;
  margin-bottom: 6px;
}
.bracket{
  position:absolute;
  top:10px;
  bottom:10px;
  width:10px;
  border-radius: 10px;
  opacity: .9;
}
.bracket.left{ left:10px; }
.bracket.right{ right:10px; }
.bracket.active{ background: rgba(255,255,255,.65); }
.bracket.controlled{ background: rgba(255,255,255,.25); }
.bracket.published{ background: rgba(43,210,126,.60); }
.bracket.planning{ background: rgba(43,210,126,.18); border:1px dashed rgba(43,210,126,.30); background-clip: padding-box; }

.weekInner{ padding-left: 22px; padding-right: 22px; }
.shiftList{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
  gap:8px;
}
.shiftCard{
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  border-radius: 12px;
  padding: 8px 10px;
}
.shiftCard .t{ font-weight: 900; font-size: 12px; }
.shiftCard .s{ color: var(--muted); font-size: 11px; margin-top: 2px; }
.badgeWarn{
  display:inline-flex;
  gap:6px;
  align-items:center;
  margin-top: 6px;
  font-size: 11px;
  font-weight: 900;
  color: rgba(244,197,66,.95);
}
.smallNote{ font-size: 11px; color: var(--muted); margin-top: 8px; line-height:1.25; }

    /* ===================== CONTRAST / LEGIBILITY FIXES ===================== */
    /* Dropdowns: force readable (dark text on light background) */
    select{
      background: rgba(255,255,255,.96) !important;
      color:#0b1020 !important;
      border:1px solid rgba(0,0,0,.35) !important;
      box-shadow:none !important;
    }
    select option{
      background:#ffffff !important;
      color:#0b1020 !important;
    }
    select:focus{
      outline: 3px solid rgba(124,92,255,.35) !important;
      outline-offset: 2px !important;
    }

    /* Modal/dialog panels: reduce transparency so text is easy to read */
    .modal{
      background: rgba(15,23,49,.98) !important;
    }


</style>
</head>

<body>

<header>
  <div class="pill">Member Scheduling</div>

  <div class="pill">
    Member:
    <select id="member"></select>
  </div>

  <div class="pill" id="rosterPill" title="Roster source: unknown">Roster: <span id="rosterTip">…</span></div>

  <div class="savePill" id="savepill" title="Checking…">
    <span class="dot warn" id="driveDot"></span>
    <span class="tiny" id="driveTip">Checking…</span>
  </div>
</header>

<!-- Lite Security Login Modal -->
<div id="authModal" class="modal" style="display:none; position:fixed; inset:0; z-index:9999; background:rgba(0,0,0,.6);">
  <div style="max-width:460px; margin:8vh auto; background:rgba(15,23,49,.98); border:1px solid rgba(255,255,255,.18); border-radius:16px; padding:16px 16px 14px;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
      <div style="font-weight:800; letter-spacing:.2px;">Sign in</div>
      <div class="tiny" id="authModeTip" style="opacity:.8;">Lite security</div>
    </div>
    <div class="tiny" style="opacity:.75; margin-top:6px;">
      Select your name, then enter your PIN. This prevents accidental/mischief logins without turning it into “Fort Knox”.
    </div>

    <div style="margin-top:12px; display:grid; gap:10px;">
      <label class="tiny" style="opacity:.85;">Selected member</label>
      <div class="pill" style="justify-content:space-between;">
        <span id="authMemberName">—</span>
        <span class="tiny" id="authMemberId" style="opacity:.6;"></span>
      </div>

      <label class="tiny" style="opacity:.85;">PIN</label>
      <input id="authPin" type="password" inputmode="numeric" autocomplete="off"
             placeholder="Enter PIN" style="width:100%; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.18); background:#fff; color:#0b1020; font-weight:700;">
      <div class="tiny" id="authError" style="color:#ffb3b3; display:none;"></div>

      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:6px;">
        <button id="authCancel" class="btn" type="button" style="opacity:.85;">Cancel</button>
        <button id="authGo" class="btn primary" type="button">Unlock</button>
      </div>

      <div class="tiny" style="opacity:.55; margin-top:4px;">
        Tip: PINs live in members.json as <code>pin_hash</code> (SHA-256). Ask an admin if yours isn’t set yet.
      </div>
    </div>
  </div>
</div>


<div class="tabbar">
  <div class="tabbtn active" data-tab="tabAvail">Availability</div>
  <div class="tabbtn" data-tab="tabPrefs">Preferences</div>
  <div class="tabbtn" data-tab="tabImpact">Impact</div>
</div>

<main>
  <!-- Availability -->
  <section id="tabAvail" class="tab active">
    <div class="panel">
      <div class="panelTitle">Global preferences</div>
      <div class="panelHint">
        These don’t block staffing — they simply help the solver break ties and reduce friction.
      </div>

      <div class="togRow">
        <label class="toggle">
          <input id="chkPrefer24" type="checkbox">
          <span class="col">
            <span class="lbl">Prefer 24-hour shifts</span>
            <span class="sub">Small bonus for AM↔PM or PM→next AM continuity when possible.</span>
          </span>
        </label>

        <label class="toggle">
          <input id="chkBlankOk" type="checkbox" checked>
          <span class="col">
            <span class="lbl">If I left a day blank, you may still schedule me if needed</span>
            <span class="sub">Blank stays eligible (0 points). Turn off if you don’t want “lingering zero” pull-ins.</span>
          </span>
        </label>
      </div>
    </div>

    <div class="panel">
      <div class="panelTitle">Quick Set (Bulk)</div>
      <div class="panelHint">Stamp a baseline fast, then click pills below to fine-tune exceptions.</div>

      <div class="bulkGrid">
        <label class="bulkField">
          <span>Pattern</span>
          <select id="bulkPattern">
            <option value="week1">Repeat 1-week template</option>
            <option value="week2">Alternate 2-week templates</option>
          </select>
        </label>

        <label class="bulkField">
          <span>From</span>
          <input id="bulkFrom" type="date">
        </label>

        <label class="bulkField">
          <span>To</span>
          <input id="bulkTo" type="date">
        </label>

        <div class="bulkBtns">
          <button id="btnRepeatUntil" class="bbtn primary" type="button">Copy this week → until date</button>
          <button id="btnApplyRange" class="bbtn ghost" type="button">Apply pattern to range</button>
          <button id="btnClearRange" class="bbtn danger" type="button">Clear range</button>
        </div>
      </div>

      <div class="smallNote">
        Tip: click the <b>day number</b> to set AM+PM together (fast “full-day” change).
      </div>
    </div>

    <div id="months"></div>
  </section>

  <!-- Preferences -->
  <section id="tabPrefs" class="tab">
    <div class="panel">
      <div class="panelTitle">Compatibility (soft)</div>
      <div class="panelHint">
        “Rather not work with” is a soft preference. It never blocks staffing and never penalizes the other person.
        If a conflict exists, <b>you</b> may lose a few points so someone else can win that seat when possible.
      </div>

      <div class="searchRow">
        <input id="avoidSearch" type="text" placeholder="Search roster…" />
        <button id="btnAvoidClear" class="bbtn danger" type="button">Clear list</button>
      </div>

      <div id="avoidRoster" class="roster"></div>

      <div class="smallNote">
        Private by default: this tab stays tucked away so availability stays clean and non-social.
      </div>
    </div>
  </section>

  <!-- Impact -->
  <section id="tabImpact" class="tab">
    <div class="panel">
      <div class="panelTitle">Impact (read-only)</div>
      <div class="panelHint">
        This view mirrors the “Published” window so you can see the real-world effect of your changes.
        If you drop something critical, you’ll see a warning icon — the shift won’t flip to “OPEN” until on-deck outreach is exhausted.
      </div>
    </div>

    <div id="impactWrap"></div>
  </section>
</main>

<script>
/* ===================== DRIVE STORE CONFIG ===================== */
const STORE = {
  // Prefer same-origin /api/store when hosted, but fall back to the Worker when opened as a local file.
  url: "https://schedule-cors-910cpr.brian-9ac.workers.dev"};


// ---- org_settings (shared config) ----
const DEFAULT_ORG = {
  weeks: { archived: 1, controlled: 2, published: 2, planning: 6 },
  pay: { shift_hours: { AM: 12, PM: 12 } },
  ui: {
    use_first_name_only: true,
    grey_past_days: true,
    show_health_for_past_days: false,
    show_needs_in: { controlled_week_index: 1, planning_week_index: 0 }
  }
};
let ORG = structuredClone(DEFAULT_ORG);

function shiftHoursForMemberView(shift){
  const sh = String(shift||'').toUpperCase();
  const h = ORG?.pay?.shift_hours?.[sh];
  const n = Number(h);
  return Number.isFinite(n) && n > 0 ? n : 12;
}

function payCfgForMemberId(memberId){
  const m = ROSTER_FULL_BY_ID[String(memberId)] || {};
  const rate = Number(m.hourly_rate);
  const thr = Number(m.ot_threshold_hours);
  const mult = Number(m.ot_multiplier);
  return {
    hourly_rate: Number.isFinite(rate) ? rate : 0,
    ot_threshold_hours: Number.isFinite(thr) ? thr : 40,
    ot_multiplier: Number.isFinite(mult) ? mult : 1.5
  };
}

function computePayWindow(memberId){
  // Returns { total_hours, total_est_pay, weeks:[{week_start, hours, ot_hours, reg_hours, est_pay}] }
  const out = { total_hours:0, total_est_pay:0, weeks:[] };
  if(!SCHEDULE_CACHE) return out;

  const counts = (ORG && ORG.weeks) ? ORG.weeks : DEFAULT_ORG.weeks;
  const controlledN = Number(counts.controlled||2);
  const publishedN  = Number(counts.published||2);
  const totalWeeks = controlledN + publishedN;

  const cfg = payCfgForMemberId(memberId);
  const baseStart = startOfWeekThursday(new Date());

  for(let w=0; w<totalWeeks; w++){
    const ws = addDays(baseStart, w*7);
    let hours = 0;
    for(let i=0;i<7;i++){
      const ds = iso(addDays(ws, i));
      const day = SCHEDULE_CACHE[ds] || {};
      for(const shift of ['AM','PM']){
        const pair = day[shift] || day[shift.toLowerCase()] || null;
        if(!pair || !Array.isArray(pair) || pair.length < 2) continue;
        const a = String(pair[0]||'').trim();
        const b = String(pair[1]||'').trim();
        if(a === String(memberId) || b === String(memberId)){
          hours += shiftHoursForMemberView(shift);
        }
      }
    }

    const ot = Math.max(0, hours - cfg.ot_threshold_hours);
    const reg = Math.max(0, hours - ot);
    const est = (cfg.hourly_rate>0) ? (reg*cfg.hourly_rate + ot*cfg.hourly_rate*cfg.ot_multiplier) : 0;

    out.weeks.push({
      week_start: iso(ws),
      hours: Math.round(hours*100)/100,
      ot_hours: Math.round(ot*100)/100,
      reg_hours: Math.round(reg*100)/100,
      est_pay: Math.round(est*100)/100
    });

    out.total_hours += hours;
    out.total_est_pay += est;
  }

  out.total_hours = Math.round(out.total_hours*100)/100;
  out.total_est_pay = Math.round(out.total_est_pay*100)/100;
  return out;
}


async function loadOrgSettings(){
  try{
    const resp = await fetch(`${STORE.url}?kind=org_settings`, { cache:"no-store" });
    const j = await resp.json();
    const p = j?.payload || {};
    ORG = {
      ...DEFAULT_ORG,
      ...p,
      weeks: { ...DEFAULT_ORG.weeks, ...(p.weeks||{}) },
      ui: { ...DEFAULT_ORG.ui, ...(p.ui||{}), show_needs_in: { ...DEFAULT_ORG.ui.show_needs_in, ...(p.ui?.show_needs_in||{}) } }
    };
  }catch(_e){
    ORG = structuredClone(DEFAULT_ORG);
  }
}

/* ===================== CONFIG ===================== */
const MONTHS_AHEAD = 6;
const STATES = ["clear","pref","avail","no"];
const AV_KIND = "member_availability";

// Optional (Impact tab) kinds. Beta1 reads if present; otherwise shows “not connected”
const ASSIGN_KIND = "member_assignments"; // suggested format below

/* ===================== STATE ===================== */
const today = new Date();

// availability state: dateISO -> {am, pm}
const stateDays = {};

// prefs state
let prefs = {
  prefer_24: false,
  blank_ok: true,     // if false, blank becomes slight penalty in solver later
  avoid_with: []      // array of member_ids
};

// roster (for avoid list)
let roster = [
  { id:"203", name:"Lynnsey Benson", meta:"" },
  { id:"brian", name:"Brian Ennis", meta:"" }
];

// Full member records (from kind=members) so we can read qualifications
let ROSTER_FULL_BY_ID = {}; // id -> full member object
function setRosterFull(list){
  ROSTER_FULL_BY_ID = {};
  (list||[]).forEach(m=>{
    const id = String(m.member_id ?? m.id ?? "").trim();
    if(id) ROSTER_FULL_BY_ID[id] = m;
  });
}
function memberQuals(memberId){
  const m = ROSTER_FULL_BY_ID[String(memberId)];
  const q = Array.isArray(m?.qualifications) ? m.qualifications : (Array.isArray(m?.quals) ? m.quals : []);
  return new Set((q||[]).map(String));
}


// published assignments for member (Impact tab), if available
// expected structure:
// { weeks: [ { phase:"published|controlled|active|planning", week_start:"YYYY-MM-DD", items:[{date:"YYYY-MM-DD", shift:"AM|PM", role:"EMT|ALS|Driver", status:"OK|ON_DECK|OPEN", note:"..."} ] } ] }
let memberAssignments = null;

/* ===================== HELPERS ===================== */

/* ===================== LITE SECURITY ===================== */
const AUTH = {
  enabled: true,             // can be disabled via org_settings.security.enabled=false
  session_hours: 8,
  max_fails: 5,
  lock_minutes: 10
};
function authKey(memberId){ return `sc:auth:${memberId}`; }
function authFailKey(memberId){ return `sc:authfail:${memberId}`; }

async function sha256Hex(str){
  const enc = new TextEncoder().encode(String(str));
  const buf = await crypto.subtle.digest("SHA-256", enc);
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
}
function nowMs(){ return Date.now(); }

function isAuthed(memberId){
  try{
    const raw = localStorage.getItem(authKey(memberId));
    if(!raw) return false;
    const j = JSON.parse(raw);
    const ttl = Number(AUTH.session_hours||8) * 3600 * 1000;
    return !!j?.ok && (nowMs() - Number(j.ts||0) < ttl);
  }catch(e){ return false; }
}
function setAuthed(memberId){
  try{ localStorage.setItem(authKey(memberId), JSON.stringify({ ok:true, ts: nowMs() })); }catch(e){}
}
function clearAuthed(memberId){
  try{ localStorage.removeItem(authKey(memberId)); }catch(e){}
}

function getFailState(memberId){
  try{
    const raw = localStorage.getItem(authFailKey(memberId));
    if(!raw) return { fails:0, locked_until:0 };
    const j = JSON.parse(raw);
    return { fails:Number(j.fails||0), locked_until:Number(j.locked_until||0) };
  }catch(e){ return { fails:0, locked_until:0 }; }
}
function setFailState(memberId, st){
  try{ localStorage.setItem(authFailKey(memberId), JSON.stringify(st||{})); }catch(e){}
}

function showAuthModal({memberId, memberName, onSuccess}){
  const modal = document.getElementById("authModal");
  const pin = document.getElementById("authPin");
  const err = document.getElementById("authError");
  const nameEl = document.getElementById("authMemberName");
  const idEl = document.getElementById("authMemberId");
  if(!modal || !pin) return;

  nameEl.textContent = memberName || "—";
  idEl.textContent = memberId ? `#${memberId}` : "";
  err.style.display="none";
  err.textContent="";
  pin.value="";
  modal.style.display="block";
  setTimeout(()=> pin.focus(), 50);

  const close = ()=>{
    modal.style.display="none";
    pin.value="";
  };

  const cancelBtn = document.getElementById("authCancel");
  const goBtn = document.getElementById("authGo");

  const handler = async ()=>{
    const mid = String(memberId||"").trim();
    const full = (window.ROSTER_FULL_BY_ID || {})[mid] || null;
    const sec = (window.ORG?.security) ? window.ORG.security : null;
    const enabled = (sec && sec.enabled === false) ? false : true;
    if(!enabled){
      setAuthed(mid);
      close();
      onSuccess && onSuccess();
      return;
    }

    const st = getFailState(mid);
    if(st.locked_until && nowMs() < st.locked_until){
      const mins = Math.ceil((st.locked_until - nowMs())/60000);
      err.textContent = `Too many tries. Locked for ~${mins} min.`;
      err.style.display="block";
      return;
    }

    const entered = String(pin.value||"").trim();
    if(!entered){
      err.textContent = "Enter your PIN.";
      err.style.display="block";
      return;
    }

    // expected hash from member record
    const expected = String(full?.pin_hash || "").trim();
    if(!expected){
      err.textContent = "PIN not set for this member yet. Ask an admin.";
      err.style.display="block";
      return;
    }

    const salt = String(sec?.salt || "").trim();
    const h = await sha256Hex(salt ? (salt + ":" + entered) : entered);

    if(h === expected){
      setAuthed(mid);
      setFailState(mid, { fails:0, locked_until:0 });
      close();
      onSuccess && onSuccess();
      return;
    }

    // fail path
    const fails = (st.fails||0) + 1;
    const locked = fails >= Number(AUTH.max_fails||5);
    setFailState(mid, {
      fails,
      locked_until: locked ? (nowMs() + Number(AUTH.lock_minutes||10)*60000) : 0
    });
    err.textContent = locked ? "Too many incorrect PIN attempts. Try again later." : "Incorrect PIN.";
    err.style.display="block";
  };

  const cleanup = ()=>{
    cancelBtn?.removeEventListener("click", onCancel);
    goBtn?.removeEventListener("click", onGo);
    pin?.removeEventListener("keydown", onKey);
  };

  const onCancel = ()=>{ cleanup(); close(); };
  const onGo = async ()=>{ await handler(); if(modal.style.display==="none") cleanup(); };
  const onKey = async (e)=>{ if(e.key==="Enter"){ e.preventDefault(); await onGo(); } };

  cancelBtn?.addEventListener("click", onCancel);
  goBtn?.addEventListener("click", onGo);
  pin?.addEventListener("keydown", onKey);
}

async function ensureAuthForSelectedMember(){
  const memberId = getActiveMemberId();
  const memberName = getActiveMemberName();
  const enabled = (window.ORG?.security && window.ORG.security.enabled === false) ? false : true;
  if(!enabled) return true;

  if(isAuthed(memberId)) return true;

  return await new Promise(resolve=>{
    showAuthModal({
      memberId, memberName,
      onSuccess: ()=> resolve(true)
    });
  });
}


function iso(d){ return d.toISOString().slice(0,10); }
function parseISO(s){ const [y,m,d]=s.split("-").map(Number); return new Date(y,m-1,d); }
function addDays(d,n){ const x=new Date(d.getTime()); x.setDate(x.getDate()+n); return x; }
function cycle(s){ return STATES[(STATES.indexOf(s)+1)%STATES.length]; }
function isPast(isoDate){ return isoDate < iso(new Date()); }

function getActiveMemberId(){
  const sel = document.getElementById("member");
  return sel ? String(sel.value || "").trim() : "default";
}
function getActiveMemberName(){
  const sel = document.getElementById("member");
  if(!sel) return "";
  return sel.options[sel.selectedIndex]?.textContent || "";
}

/* Thu→Wed week anchor */
function startOfWeekThursday(d){
  const x = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  const dow = x.getDay(); // 0..6
  const target = 4; // Thu
  const delta = (dow - target + 7) % 7;
  return addDays(x, -delta);
}


/* ===================== IMPACT HELPERS (schedule-derived) ===================== */
function buildMemberWeekItems(schedule, memberId, weekStartDate){
  const items = [];
  for(let i=0;i<7;i++){
    const d = addDays(weekStartDate, i);
    const ds = iso(d);
    const day = schedule[ds] || {};
    for(const shift of ["AM","PM"]){
      const pair = day[shift] || day[shift.toLowerCase()] || null;
      if(!pair || !Array.isArray(pair) || pair.length < 2) continue;
      const a = String(pair[0]||"").trim();
      const dr = String(pair[1]||"").trim();
      if(a === memberId || dr === memberId){
        const role = (a === memberId) ? "Attendant" : "Driver";
        items.push({ date: ds, shift, role, status:"OK", note: role });
      }
    }
  }
  return items;
}


/* ===================== SCHEDULE COMMITMENTS (overlay) ===================== */
// Overlay the authoritative schedule onto the Availability calendar.
// Members can see what they're already on, and requesting off becomes a DROP request.
let SCHEDULE_CACHE = null;   // normalized schedule map with YYYY-MM-DD keys
let SCHEDULE_META = null;    // schedule.meta if present
let COMMIT = {};             // { [dateISO]: { AM:true/false, PM:true/false } }

function normalizeScheduleMapForMember(obj){
  // tolerate store envelopes; keep meta if present; keep only YYYY-MM-DD keys
  if(!obj || typeof obj !== 'object') return {};
  let x = obj;
  for(let i=0;i<6;i++){
    if(x && typeof x==='object' && x.payload && typeof x.payload==='object') x = x.payload;
    else break;
  }
  const out = {};
  if(x.meta && typeof x.meta === 'object') out.meta = x.meta;
  for(const [k,v] of Object.entries(x||{})){
    if(/^\d{4}-\d{2}-\d{2}$/.test(k) && v && typeof v === 'object') out[k]=v;
  }
  return out;
}

function computeCommitments(schedule, memberId){
  COMMIT = {};
  if(!schedule || typeof schedule !== 'object') return;
  for(const [ds, day] of Object.entries(schedule)){
    if(ds === 'meta') continue;
    const d = day || {};
    for(const shift of ['AM','PM']){
      const pair = d[shift] || d[shift.toLowerCase()] || null;
      if(!pair || !Array.isArray(pair) || pair.length < 2) continue;
      const a = String(pair[0]||'').trim();
      const b = String(pair[1]||'').trim();
      if(a === memberId || b === memberId){
        COMMIT[ds] ||= { AM:false, PM:false };
        COMMIT[ds][shift] = true
      }
    }
  }
}

function isCommitted(dateISO, shift){
  return !!(COMMIT[dateISO] && COMMIT[dateISO][shift]);
}

function phaseForDate(dateISO){
  // Uses the same Thu->Wed week anchor as Impact.
  // Uses ORG.weeks.controlled / ORG.weeks.published counts.
  const d = parseISO(dateISO);
  const thisStart = startOfWeekThursday(new Date());
  const ws = startOfWeekThursday(d);
  const weekIndex = Math.floor((ws.getTime() - thisStart.getTime()) / (7*24*60*60*1000));
  const counts = (ORG && ORG.weeks) ? ORG.weeks : DEFAULT_ORG.weeks;
  const controlledN = Number(counts.controlled||2);
  const publishedN  = Number(counts.published||2);
  if(weekIndex < 0) return 'archived';
  if(weekIndex < controlledN) return 'controlled';
  if(weekIndex < controlledN + publishedN) return 'published';
  return 'planning';
}

async function loadScheduleCommitments(memberId){
  try{
    const raw = await storeGet({ kind:'schedule' });
    const sched = normalizeScheduleMapForMember(raw);
    SCHEDULE_META = sched.meta || null;
    // keep schedule days in cache (without meta key)
    const cache = { ...sched };
    delete cache.meta;
    SCHEDULE_CACHE = cache;
    computeCommitments(cache, memberId);
  }catch(_e){
    SCHEDULE_CACHE = null;
    SCHEDULE_META = null;
    COMMIT = {};
  }
}

async function submitDropRequest(dateISO, shift){
  const memberId = getActiveMemberId();
  const memberName = getActiveMemberName();

  // Read supervisor_patch, append request, write back.
  // This is intentionally minimal and only touches the .requests array.
  const now = nowISO();
  const phase = phaseForDate(dateISO);
  const req = {
    id: `req_${memberId}_${dateISO}_${shift}_${Date.now()}`,
    member_id: memberId,
    member_name: memberName,
    date: dateISO,
    shift: shift,
    action: 'DROP',
    phase: phase,
    status: 'PENDING',
    created_at: now,
    schedule_resolved_at: (SCHEDULE_META && SCHEDULE_META.resolved_at) ? String(SCHEDULE_META.resolved_at) : null
  };

  // Safety: only allow requests for controlled/published
  if(!(phase === 'controlled' || phase === 'published')){
    return { ok:false, error:'Not in controlled/published window' };
  }

  let patch = {};
  try{
    const got = await storeGet({ kind:'supervisor_patch' });
    patch = (got && got.payload && typeof got.payload === 'object') ? got.payload : (got && typeof got === 'object' ? got : {});
  }catch(_e){
    patch = {};
  }

  const list = Array.isArray(patch.requests) ? patch.requests.slice() : [];
  // prevent identical duplicates
  const dup = list.find(x => x && x.member_id === memberId && x.date === dateISO && x.shift === shift && x.action === 'DROP' && (x.status||'PENDING') === 'PENDING');
  if(dup){
    return { ok:true, duplicate:true };
  }
  list.push(req);
  patch.requests = list;

  try{
    await storePut({ kind:'supervisor_patch', payload: patch });
    return { ok:true };
  }catch(e){
    return { ok:false, error:String(e.message||e) };
  }
}
/* ===================== STORE HELPERS ===================== */
async function readJsonOrThrow(resp){
  // Google sometimes returns an HTML login/error page with status 200.
  const ct = (resp.headers.get("content-type") || "").toLowerCase();
  const text = await resp.text();
  if(!ct.includes("application/json")){
    const head = text.slice(0, 200).replace(/\s+/g," ").trim();
    throw new Error(`Store returned non-JSON (${resp.status}). First 200 chars: ${head}`);
  }
  try{
    return JSON.parse(text);
  }catch(e){
    const head = text.slice(0, 200).replace(/\s+/g," ").trim();
    throw new Error(`Store JSON parse failed (${resp.status}). First 200 chars: ${head}`);
  }
}

function withStoreDefaults(obj){
  // Never send token from browser — Worker injects it.
  return { ...(obj || {}) };
}

async function storeGet(params){
  const u = new URL(STORE.url);
  const all = withStoreDefaults(params || {});
  Object.entries(all).forEach(([k,v]) => u.searchParams.set(k, String(v)));
  const resp = await fetch(u.toString(), { cache:"no-store" });
  const j = await readJsonOrThrow(resp);
  if(!j.ok) throw new Error(j.error || "Store GET failed");
  return j.payload;
}

async function storePut(body){
  const resp = await fetch(STORE.url, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify(withStoreDefaults(body || {}))
  });
  const j = await readJsonOrThrow(resp);
  if(!j.ok) throw new Error(j.error || "Store PUT failed");
  return j.payload;
}

/* ===================== SAVE PILL ===================== */
function setDrivePill({state, label, tooltip}){
  const dot = document.getElementById("driveDot");
  const tip = document.getElementById("driveTip");
  const pill = document.getElementById("savepill");
  if(!dot || !tip || !pill) return;
  dot.classList.remove("ok","warn");
  dot.classList.add(state === "ok" ? "ok" : "warn");
  tip.textContent = label;
  pill.title = tooltip || label;
}

/* ===================== LOCAL + DRIVE PERSISTENCE ===================== */
const LS_PREFIX = "sc:avail:";
const LS_META_PREFIX = "sc:availmeta:";

function nowISO(){ return new Date().toISOString(); }
function lsKey(memberId){ return LS_PREFIX + memberId; }
function lsMetaKey(memberId){ return LS_META_PREFIX + memberId; }

function getLocalPayload(memberId){
  try{
    const raw = localStorage.getItem(lsKey(memberId));
    return raw ? JSON.parse(raw) : null;
  }catch(e){ return null; }
}
function setLocalPayload(memberId, payload){
  localStorage.setItem(lsKey(memberId), JSON.stringify(payload));
}
function getMeta(memberId){
  try{
    const raw = localStorage.getItem(lsMetaKey(memberId));
    return raw ? JSON.parse(raw) : { dirty:false, lastPushISO:null, lastError:null };
  }catch(e){
    return { dirty:false, lastPushISO:null, lastError:null };
  }
}
function setMeta(memberId, meta){
  localStorage.setItem(lsMetaKey(memberId), JSON.stringify(meta));
}

function applyPayload(payload){
  if(!payload) return;
  if(payload.prefs){
    prefs = {
      prefer_24: !!payload.prefs.prefer_24,
      blank_ok: payload.prefs.blank_ok !== false,
      avoid_with: Array.isArray(payload.prefs.avoid_with) ? payload.prefs.avoid_with.slice() : []
    };
  }
  if(payload.days){
    for(const [dateISO, v] of Object.entries(payload.days)){
      stateDays[dateISO] ||= { am:"clear", pm:"clear" };
      if(v && typeof v === "object"){
        if(v.am) stateDays[dateISO].am = v.am;
        if(v.pm) stateDays[dateISO].pm = v.pm;
      }
    }
  }
}

let syncTimer = null;

function markDirty(memberId){
  const meta = getMeta(memberId);
  meta.dirty = true;
  meta.lastError = null;
  setMeta(memberId, meta);
  setDrivePill({ state:"warn", label:"Saving…", tooltip:"Saved locally. Syncing to Drive…" });
}

function scheduleSync(memberId){
  if(syncTimer) clearTimeout(syncTimer);
  syncTimer = setTimeout(()=> trySync(memberId), 650);
}

async function trySync(memberId){
  const meta = getMeta(memberId);
  if(!meta.dirty) return;

  const payload = {
    updated_at: nowISO(),
    prefs: {
      prefer_24: !!prefs.prefer_24,
      blank_ok: prefs.blank_ok !== false,
      avoid_with: Array.isArray(prefs.avoid_with) ? prefs.avoid_with.slice() : []
    },
    days: stateDays
  };

  setLocalPayload(memberId, payload);

  if(!navigator.onLine){
    setDrivePill({ state:"warn", label:"Saved locally", tooltip:"Offline. Will sync when back online." });
    return;
  }

  try{
    await storePut({ kind: AV_KIND, member_id: memberId, payload });

    meta.dirty = false;
    meta.lastPushISO = nowISO();
    meta.lastError = null;
    setMeta(memberId, meta);

    setDrivePill({ state:"ok", label:"Saved", tooltip:`Synced to Drive.\nLast sync: ${meta.lastPushISO}` });
  }catch(err){
    meta.lastError = String(err.message || err);
    setMeta(memberId, meta);
    setDrivePill({ state:"warn", label:"Saved locally", tooltip:`Drive sync failed.\n${meta.lastError}\nStill saved locally.` });
  }
}

function onAnyChange(){
  const memberId = getActiveMemberId();
  markDirty(memberId);
  scheduleSync(memberId);
}

async function loadMember(memberId){
  // local first
  const local = getLocalPayload(memberId);
  if(local){
    applyPayload(local);
    setDrivePill({ state:"warn", label:"Loaded", tooltip:"Loaded locally. Checking Drive…" });
  }else{
    setDrivePill({ state:"warn", label:"Checking…", tooltip:"Checking Drive…" });
  }

  // drive authoritative
  try{
    const remote = await storeGet({ kind: AV_KIND, member_id: memberId });
    if(remote){
      // reset local state then apply
      for(const k of Object.keys(stateDays)) delete stateDays[k];
      prefs = { prefer_24:false, blank_ok:true, avoid_with:[] };
      applyPayload(remote);
      setLocalPayload(memberId, remote);

      const meta = getMeta(memberId);
      meta.dirty = false;
      meta.lastPushISO = nowISO();
      meta.lastError = null;
      setMeta(memberId, meta);

      setDrivePill({ state:"ok", label:"Saved", tooltip:"Loaded from Drive and ready." });
    }else{
      setDrivePill({ state:"ok", label:"Saved", tooltip:"No Drive record yet — starting fresh." });
    }
  }catch(err){
    setDrivePill({ state:"warn", label:"Local only", tooltip:`Couldn’t reach Drive.\n${err.message || err}\nWorking locally.` });
  }

  // refresh UI
  syncPrefsUI();
  await loadScheduleCommitments(memberId);
  buildCalendar();
  renderAvoidRoster();
  await loadImpact(); // best effort
}

window.addEventListener("online", ()=> trySync(getActiveMemberId()));

/* ===================== TAB UI ===================== */
function setTab(id){
  document.querySelectorAll(".tab").forEach(el=> el.classList.remove("active"));
  document.querySelectorAll(".tabbtn").forEach(el=> el.classList.remove("active"));
  document.getElementById(id)?.classList.add("active");
  document.querySelector(`.tabbtn[data-tab="${id}"]`)?.classList.add("active");
  if(id === "tabImpact") loadImpact(); // refresh when opening
}
document.querySelectorAll(".tabbtn").forEach(btn=>{
  btn.addEventListener("click", ()=> setTab(btn.dataset.tab));
});

/* ===================== ROSTER LOAD (optional) ===================== */
/* ===================== ROSTER LOAD (Drive + cache) ===================== */
const LS_ROSTER_KEY = "sc:roster:cache:v1";

function setRosterPill(text, title){
  const tip = document.getElementById("rosterTip");
  const pill = document.getElementById("rosterPill");
  if(tip) tip.textContent = text;
  if(pill) pill.title = title || text;
}

function loadRosterCache(){
  try{
    const raw = localStorage.getItem(LS_ROSTER_KEY);
    const j = raw ? JSON.parse(raw) : null;
    if(j && Array.isArray(j.roster) && j.roster.length) return j;
  }catch(e){}
  return null;
}

function saveRosterCache(list){
  try{
    localStorage.setItem(LS_ROSTER_KEY, JSON.stringify({
      cached_at: nowISO(),
      roster: list
    }));
  }catch(e){}
}

function normalizeRoster(list){
  return (list || [])
    .map(x => {
      const id = String(x.id ?? x.member_id ?? x.memberId ?? x.member ?? "").trim();
      const first = String(x.first_name ?? x.firstName ?? "").trim();
      const last  = String(x.last_name ?? x.lastName ?? "").trim();

      // prefer explicit name fields, else build from first+last, else fallback to id
      const explicit =
        String(
          x.name ?? x.full_name ?? x.fullName ?? x.display ?? x.display_name ??
          x.callsign ?? x.last_first ?? ""
        ).trim();

      const built = (first || last) ? `${first} ${last}`.trim() : "";
      const name = explicit || built || id;

      const meta = String(x.meta ?? x.role ?? x.rank ?? x.title ?? "").trim();
      return { id, name, meta };
    })
    .filter(x => x.id && x.name)
    .sort((a,b)=> a.name.localeCompare(b.name));
}

async function tryLoadRoster({force=false} = {}){
  // 1) Cache first (fast)
  if(!force){
    const cached = loadRosterCache();
    if(cached){
      roster = normalizeRoster(cached.roster);
      setRosterPill("cached", `Roster from cache (${cached.cached_at})`);
    }
  }

  // 2) Drive authoritative (best effort)
  try{
    const r = await storeGet({ kind:"members" });
    const list = Array.isArray(r) ? r : (r && Array.isArray(r.members) ? r.members : (r && Array.isArray(r.payload) ? r.payload : null));
    if(list && list.length){
      setRosterFull(list);
      roster = normalizeRoster(list);
      saveRosterCache(roster);
      setRosterPill("Drive", "Roster loaded from Google Drive");
      return true;
    }
    setRosterPill("empty", "Drive returned no roster records");
  }catch(e){
    // keep whatever we have (fallback or cache)
    setRosterPill("offline", `Roster not reachable — using fallback/cache. (${String(e.message||e)})`);
  }
  return false;
}


/* ===================== PREFS UI ===================== */
function syncPrefsUI(){
  const chk24 = document.getElementById("chkPrefer24");
  const chkBlank = document.getElementById("chkBlankOk");
  if(chk24) chk24.checked = !!prefs.prefer_24;
  if(chkBlank) chkBlank.checked = prefs.blank_ok !== false;
}
document.getElementById("chkPrefer24")?.addEventListener("change", (e)=>{
  prefs.prefer_24 = !!e.target.checked;
  onAnyChange();
});
document.getElementById("chkBlankOk")?.addEventListener("change", (e)=>{
  prefs.blank_ok = !!e.target.checked;
  onAnyChange();
});

/* ===================== AVOID LIST UI ===================== */
function renderAvoidRoster(){
  const wrap = document.getElementById("avoidRoster");
  if(!wrap) return;

  const q = (document.getElementById("avoidSearch")?.value || "").trim().toLowerCase();
  wrap.innerHTML = "";

  const activeId = getActiveMemberId();
  const list = roster
    .filter(p => p.id !== activeId)
    .filter(p => !q || p.name.toLowerCase().includes(q) || (p.meta||"").toLowerCase().includes(q))
    .sort((a,b)=> a.name.localeCompare(b.name));

  for(const p of list){
    const el = document.createElement("label");
    el.className = "person";

    const checked = prefs.avoid_with.includes(p.id);
    el.innerHTML = `
      <input type="checkbox" ${checked ? "checked":""}/>
      <div style="display:flex;flex-direction:column;">
        <div class="name">${escapeHtml(p.name)}</div>
        <div class="meta">${escapeHtml(p.meta || "")}</div>
      </div>
    `;

    const cb = el.querySelector("input");
    cb.addEventListener("change", ()=>{
      const has = prefs.avoid_with.includes(p.id);
      if(cb.checked && !has) prefs.avoid_with.push(p.id);
      if(!cb.checked && has) prefs.avoid_with = prefs.avoid_with.filter(x=> x !== p.id);
      onAnyChange();
    });

    wrap.appendChild(el);
  }
}

document.getElementById("avoidSearch")?.addEventListener("input", renderAvoidRoster);
document.getElementById("btnAvoidClear")?.addEventListener("click", ()=>{
  prefs.avoid_with = [];
  renderAvoidRoster();
  onAnyChange();
});

function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

/* ===================== CALENDAR BUILD ===================== */
function ensureDay(dateISO){
  stateDays[dateISO] ||= { am:"clear", pm:"clear" };
  return stateDays[dateISO];
}

function buildCalendar(){
  const wrap = document.getElementById("months");
  if(!wrap) return;
  wrap.innerHTML = "";

  let row;
  for(let i=0;i<MONTHS_AHEAD;i++){
    if(i%2===0){
      row=document.createElement("div");
      row.className="monthRow";
      wrap.appendChild(row);
    }
    row.appendChild(buildMonth(i));
  }
}

function buildMonth(offset){
  const d = new Date(today.getFullYear(), today.getMonth()+offset, 1);
  const m = d.getMonth(), y = d.getFullYear();

  const month = document.createElement("div");
  month.className="month";

  month.innerHTML = `
    <h3>${d.toLocaleString(undefined,{month:"long",year:"numeric"})}</h3>
    <div class="dow">${["S","M","T","W","T","F","S"].map(x=>`<div>${x}</div>`).join("")}</div>
    <div class="grid"></div>
  `;

  const grid = month.querySelector(".grid");
  const start = new Date(y,m,1).getDay();
  const days  = new Date(y,m+1,0).getDate();

  for(let i=0;i<start;i++) grid.appendChild(blankCell());

  for(let day=1; day<=days; day++){
    const dateISO = iso(new Date(y,m,day));
    grid.appendChild(dayCell(dateISO, day));
  }
  return month;
}

function blankCell(){
  const d=document.createElement("div");
  d.className="day blank";
  return d;
}

function dayCell(dateISO, day){
  ensureDay(dateISO);

  const d=document.createElement("div");
  d.className="day";
  if(isPast(dateISO)) d.classList.add("past");

  const num=document.createElement("div");
  num.className="dayNum";
  num.textContent=day;

  // Day-number toggles AM+PM together (full-day shortcut)
  num.onclick=()=>{
    // Full-day toggle is disabled if any shift is already committed.
    if(isCommitted(dateISO,'AM') || isCommitted(dateISO,'PM')){
      alert('This day includes a committed shift. Use the AM/PM bars to request a drop.');
      return;
    }
    const next = cycle(stateDays[dateISO].am);
    stateDays[dateISO].am = next;
    stateDays[dateISO].pm = next;
    render();
    onAnyChange();
    // Impact updates should reflect changes
    if(document.getElementById("tabImpact").classList.contains("active")) loadImpact();
  };

  const bars=document.createElement("div");
  bars.className="bars";

  const am=bar(async ()=>{
    if(isCommitted(dateISO,'AM')){
      const ph = phaseForDate(dateISO);
      if(ph === 'controlled' || ph === 'published'){
        const ok = confirm(`You are scheduled for ${dateISO} AM (${ph.toUpperCase()}).

Request to DROP this shift?`);
        if(!ok) return;
        const res = await submitDropRequest(dateISO,'AM');
        if(res && res.ok){
          stateDays[dateISO].am = 'no';
          render();
          onAnyChange();
          alert(res.duplicate ? 'Drop request already pending.' : 'Drop request submitted.');
        }else{
          alert('Could not submit request. ' + (res && res.error ? res.error : ''));
        }
      }else{
        alert('This shift is committed, but not in the controlled/published window.');
      }
      return;
    }
    stateDays[dateISO].am = cycle(stateDays[dateISO].am);
    render();
    onAnyChange();
    if(document.getElementById("tabImpact").classList.contains("active")) loadImpact();
  },"AM");

  const pm=bar(async ()=>{
    if(isCommitted(dateISO,'PM')){
      const ph = phaseForDate(dateISO);
      if(ph === 'controlled' || ph === 'published'){
        const ok = confirm(`You are scheduled for ${dateISO} PM (${ph.toUpperCase()}).

Request to DROP this shift?`);
        if(!ok) return;
        const res = await submitDropRequest(dateISO,'PM');
        if(res && res.ok){
          stateDays[dateISO].pm = 'no';
          render();
          onAnyChange();
          alert(res.duplicate ? 'Drop request already pending.' : 'Drop request submitted.');
        }else{
          alert('Could not submit request. ' + (res && res.error ? res.error : ''));
        }
      }else{
        alert('This shift is committed, but not in the controlled/published window.');
      }
      return;
    }
    stateDays[dateISO].pm = cycle(stateDays[dateISO].pm);
    render();
    onAnyChange();
    if(document.getElementById("tabImpact").classList.contains("active")) loadImpact();
  },"PM");

  bars.append(am, pm);
  d.append(num, bars);

  function render(){
    am.className = `bar ${stateDays[dateISO].am}${isCommitted(dateISO,'AM')?' committed':''}`;
    pm.className = `bar ${stateDays[dateISO].pm}${isCommitted(dateISO,'PM')?' committed':''}`;
  }
  render();
  return d;
}

function bar(fn, label){
  const b=document.createElement("div");
  b.className="bar";
  b.dataset.label = label;
  b.onclick = fn;
  return b;
}

/* ===================== BULK TOOLS ===================== */
function setRangeDefaults(){
  const from = addDays(new Date(), 1);
  const to   = addDays(from, 27);
  document.getElementById("bulkFrom").value = iso(from);
  document.getElementById("bulkTo").value   = iso(to);
}

function templateWeek(start){
  const out = [];
  for(let i=0;i<7;i++){
    const ds = iso(addDays(start, i));
    const v = ensureDay(ds);
    out.push({ date: ds, am: v.am, pm: v.pm });
  }
  return out;
}

// current Thu→Wed template
function templateA(){
  return templateWeek(startOfWeekThursday(new Date()));
}
// next Thu→Wed template
function templateB(){
  return templateWeek(addDays(startOfWeekThursday(new Date()), 7));
}

function applyPatternToRange(){
  const fromISO = document.getElementById("bulkFrom").value;
  const toISO   = document.getElementById("bulkTo").value;
  if(!fromISO || !toISO) return;
  const from = parseISO(fromISO);
  const to   = parseISO(toISO);
  if(to < from) return;

  const pattern = document.getElementById("bulkPattern").value;
  const A = templateA();
  const B = templateB();

  const baseStart = startOfWeekThursday(from);

  for(let d = new Date(from.getFullYear(), from.getMonth(), from.getDate());
       d <= to;
       d = addDays(d,1)){

    const ds = iso(d);
    const weekStart = startOfWeekThursday(d);
    const weekIndex = Math.floor((weekStart.getTime() - baseStart.getTime()) / (7*24*60*60*1000));
    const dayIndex = Math.floor((d.getTime() - weekStart.getTime()) / (24*60*60*1000)); // 0..6

    const src = (pattern === "week2")
      ? ((weekIndex % 2 === 0) ? A[dayIndex] : B[dayIndex])
      : A[dayIndex];

    stateDays[ds] = { am: src.am, pm: src.pm };
  }
}

// copy this week forward repeatedly until "To" date
function repeatThisWeekUntil(){
  const toISO = document.getElementById("bulkTo").value;
  if(!toISO) return;
  const to = parseISO(toISO);

  const srcStart = startOfWeekThursday(new Date());
  const A = templateWeek(srcStart);

  // start stamping from the next week boundary after today
  let stampStart = addDays(srcStart, 7);

  while(stampStart <= to){
    for(let i=0;i<7;i++){
      const ds = iso(addDays(stampStart, i));
      if(parseISO(ds) > to) break;
      stateDays[ds] = { am: A[i].am, pm: A[i].pm };
    }
    stampStart = addDays(stampStart, 7);
  }
}

function clearRange(){
  const fromISO = document.getElementById("bulkFrom").value;
  const toISO   = document.getElementById("bulkTo").value;
  if(!fromISO || !toISO) return;
  const from = parseISO(fromISO);
  const to   = parseISO(toISO);
  if(to < from) return;

  for(let d = new Date(from.getFullYear(), from.getMonth(), from.getDate());
       d <= to;
       d = addDays(d,1)){
    const ds = iso(d);
    stateDays[ds] = { am:"clear", pm:"clear" };
  }
}

function commitBulk(){
  buildCalendar();
  onAnyChange();
  if(document.getElementById("tabImpact").classList.contains("active")) loadImpact();
}

document.getElementById("btnRepeatUntil")?.addEventListener("click", ()=>{ repeatThisWeekUntil(); commitBulk(); });
document.getElementById("btnApplyRange")?.addEventListener("click", ()=>{ applyPatternToRange(); commitBulk(); });
document.getElementById("btnClearRange")?.addEventListener("click", ()=>{ clearRange(); commitBulk(); });

/* ===================== IMPACT TAB ===================== */
async function loadImpact(){
  const wrap = document.getElementById("impactWrap");
  if(!wrap) return;

  // Always render something immediately
  wrap.innerHTML = `
    <div class="panel">
      <div class="panelTitle">Published view</div>
      <div class="panelHint">Loading…</div>
    </div>
  `;

  // Best-effort fetch member assignments
  memberAssignments = null;
  try{
    const p = await storeGet({ kind: ASSIGN_KIND, member_id: getActiveMemberId() });
    if(p && p.weeks && Array.isArray(p.weeks)) memberAssignments = p;
  }catch(e){
    // ignore; we will render fallback
  }

  if(!memberAssignments){
    // Fallback: derive an "Impact" view directly from schedule.json (Drive)
    // This lets members see where they are currently assigned without needing a per-member published file yet.
    try{
      const schedule = await storeGet({ kind:"schedule" });
      const sched = schedule || {};
      const memberId = getActiveMemberId();

      const counts = (ORG && ORG.weeks) ? ORG.weeks : DEFAULT_ORG.weeks;
      const controlledN = Number(counts.controlled||2);
      const publishedN  = Number(counts.published||2);

      const thisStart = startOfWeekThursday(new Date());
      const weeks = [];

      // Controlled window: this week + next week (by config)
      for(let i=0;i<controlledN;i++){
        const ws = addDays(thisStart, i*7);
        weeks.push({ phase:"controlled", week_start: iso(ws), items: buildMemberWeekItems(sched, memberId, ws) });
      }
      // Published window immediately after controlled
      for(let i=0;i<publishedN;i++){
        const ws = addDays(thisStart, (controlledN+i)*7);
        weeks.push({ phase:"published", week_start: iso(ws), items: buildMemberWeekItems(sched, memberId, ws) });
      }

      // Render
      wrap.innerHTML = "";

      // Hours / OT summary (uses member pay fields if present)
      try{
        const memberId2 = getActiveMemberId();
        const cfg = payCfgForMemberId(memberId2);
        const roll = computePayWindow(memberId2);
        const panel = document.createElement('div');
        panel.className = 'panel';
        const hasPay = (cfg.hourly_rate && cfg.hourly_rate > 0);
        panel.innerHTML = `
          <div class="panelTitle">Hours & ${hasPay ? 'estimated pay' : 'OT'} (controlled + published)</div>
          <div class="panelHint">${hasPay ? `Rate: $${cfg.hourly_rate}/hr • OT after ${cfg.ot_threshold_hours}h @ x${cfg.ot_multiplier}` : 'No hourly rate set for this member (hours still shown).'} </div>
          <div class="smallNote" style="margin-top:8px;">Total hours: <b>${roll.total_hours}</b>${hasPay ? ` • Estimated pay: <b>$${roll.total_est_pay}</b>` : ''}</div>
          <div class="smallNote" style="margin-top:8px;">${roll.weeks.map(w=>`<span class="tag"><span class="mono">${w.week_start}</span> • ${w.hours}h (${w.ot_hours} OT)${hasPay ? ` • $${w.est_pay}` : ''}</span>`).join(' ')}</div>
        `;
        wrap.appendChild(panel);
      }catch(_e){}

      for(const w of weeks){
        wrap.appendChild(renderWeekBlock(w));
      }
      return;

    }catch(e){
      wrap.innerHTML = `
        <div class="panel">
          <div class="panelTitle">Impact not connected (yet)</div>
          <div class="panelHint">
            Couldn’t load schedule from Drive to compute impact.
          </div>
          <div class="smallNote">
            Error: ${escapeHtml(String(e.message||e))}
          </div>
        </div>
      `;
      return;
    }
  }

  // Render weeks
  wrap.innerHTML = "";
  for(const w of memberAssignments.weeks){
    wrap.appendChild(renderWeekBlock(w));
  }
}

function renderWeekBlock(w){
  const phase = String(w.phase || "published").toLowerCase();
  const weekStart = String(w.week_start || "");
  const tagLabel = phaseLabel(phase, weekStart);

  const el = document.createElement("div");
  el.className = "weekBlock";

  // brackets
  const bl = document.createElement("div");
  bl.className = `bracket left ${phase}`;
  const br = document.createElement("div");
  br.className = `bracket right ${phase}`;
  el.append(bl, br);

  const inner = document.createElement("div");
  inner.className = "weekInner";

  inner.innerHTML = `
    <div class="weekTag">${escapeHtml(tagLabel)}</div>
    <div class="shiftList"></div>
  `;

  const list = inner.querySelector(".shiftList");
  const items = Array.isArray(w.items) ? w.items : [];

  // Sort by date then shift
  items.sort((a,b)=>{
    const da = String(a.date||"");
    const db = String(b.date||"");
    if(da !== db) return da.localeCompare(db);
    return String(a.shift||"").localeCompare(String(b.shift||""));
  });

  for(const it of items){
    list.appendChild(renderShiftCard(it));
  }

  // Footer note for planning-style phases
  if(phase === "planning" && w.resolve_by){
    const note = document.createElement("div");
    note.className = "smallNote";
    note.textContent = `To be resolved on Thu ${w.resolve_by}`;
    inner.appendChild(note);
  }

  el.appendChild(inner);
  return el;
}

function phaseLabel(phase, weekStart){
  const d = weekStart ? ` — week of ${weekStart}` : "";
  if(phase === "active") return `Active${d}`;
  if(phase === "controlled") return `Controlled${d}`;
  if(phase === "planning") return `Planning${d}`;
  return `Published${d}`;
}


function activeUnitFor(dateISO, shift){
  const v = (ORG && ORG.active_units_by_date && ORG.active_units_by_date[dateISO]) ? ORG.active_units_by_date[dateISO] : {};
  const ds = (ORG && ORG.ops_defaults && ORG.ops_defaults.units) ? ORG.ops_defaults.units : {};
  if(shift === "PM") return (v.PM || ds.PM || "");
  return (v.AM || ds.AM || "");
}
function operatorQualForUnit(unitId){
  const units = Array.isArray(ORG?.units) ? ORG.units : [];
  const u = units.find(x => String(x.unit_id||"") === String(unitId));
  if(u && u.operator_qual_key) return String(u.operator_qual_key);
  // fallback: try to derive qual_driver_### from digits in unit id
  const m = String(unitId||"").match(/(\d{3})/);
  return m ? ("qual_driver_"+m[1]) : "";
}
const ALS_KEYS = ["AEMT","MEDIC","SAL-ALS"]; // ambulance ALS-required for now
function renderShiftCard(it){
  const dateISO = String(it.date||"");
  const shift = String(it.shift||"");
  const role = String(it.role||"");
  const status = String(it.status||"OK"); // OK | ON_DECK | OPEN
  const note = String(it.note||"");

  const el = document.createElement("div");
  el.className = "shiftCard";

  const dayState = stateDays[dateISO] || { am:"clear", pm:"clear" };
  const mySel = shift === "AM" ? dayState.am : dayState.pm;

  // Warning if member marked NO against a published/controlled assignment
  const conflicts = (mySel === "no");
  const shouldWarn = conflicts && (status === "OK" || status === "ON_DECK");

  el.innerHTML = `
    <div class="t">${escapeHtml(dateISO)} — ${escapeHtml(shift)} ${role ? "· "+escapeHtml(role) : ""}</div>
    <div class="s">${escapeHtml(statusDisplay(status, note))}</div>
  `;

  // Eligibility overlay (ambulance-only): inform member if they are assigned into a role they don't qualify for
  const full = ROSTER_FULL_BY_ID[getActiveMemberId()] || {};
  const quals = Array.isArray(full.qualifications) ? full.qualifications.map(String) : [];
  const qset = new Set(quals);
  const unitId = activeUnitFor(dateISO, shift);
  const opQual = operatorQualForUnit(unitId);

  // For now, ambulance is ALS-required: Attendant must be ALS-capable
  if(role === "Attendant"){
    const hasAls = ALS_KEYS.some(k => qset.has(k));
    if(!hasAls){
      const warn = document.createElement("div");
      warn.className = "badgeWarn";
      warn.textContent = "⚠️ Assigned Attendant but you are not marked ALS-capable (AEMT/MEDIC/SAL-ALS)";
      el.appendChild(warn);
    }
  }
  if(role === "Driver"){
    if(opQual && !qset.has(opQual)){
      const warn = document.createElement("div");
      warn.className = "badgeWarn";
      warn.textContent = "⚠️ Assigned Operator but missing unit clearance: " + opQual;
      el.appendChild(warn);
    }
  }
  if(unitId){
    const note2 = document.createElement("div");
    note2.className = "smallNote";
    note2.textContent = "Active unit: " + unitId;
    el.appendChild(note2);
  }


  if(shouldWarn){
    const warn = document.createElement("div");
    warn.className = "badgeWarn";
    warn.textContent = "⚠️ Availability conflict (will notify on-deck before marking OPEN)";
    el.appendChild(warn);
  }

  return el;
}

function statusDisplay(status, note){
  if(status === "OPEN") return note ? `OPEN — ${note}` : "OPEN";
  if(status === "ON_DECK") return note ? `On-deck outreach — ${note}` : "On-deck outreach in progress";
  return note ? `Scheduled — ${note}` : "Scheduled";
}

/* ===================== MEMBER SELECTOR + STARTUP ===================== */
async function init(){
  await loadOrgSettings();
  const sel = document.getElementById("member");

  // 0) Paint fallback roster immediately so page is usable even if Drive is down
  setRosterPill("fallback", "Using built-in roster (Drive not checked yet)");
  sel.innerHTML = roster.map(p=> `<option value="${escapeHtml(p.id)}">${escapeHtml(p.name)}</option>`).join("");

  // 1) Try Drive roster (will also use cache if present)
  const lastMember = localStorage.getItem("sc:last_member") || "";
  await tryLoadRoster();

  // Rebuild dropdown from refreshed roster
  sel.innerHTML = roster.map(p=> `<option value="${escapeHtml(p.id)}">${escapeHtml(p.name)}</option>`).join("");

  // Restore last selection if still present
  if(lastMember && roster.some(r=> r.id === lastMember)){
    sel.value = lastMember;
  }else{
    sel.value = roster[0]?.id || "default";
  }

  // Load current member
  setRangeDefaults();
  await loadMember(getActiveMemberId());

  // Change handler
  sel.addEventListener("change", async ()=>{
    localStorage.setItem("sc:last_member", getActiveMemberId());

    // reset in-memory (but keep localStorage)
    for(const k of Object.keys(stateDays)) delete stateDays[k];
    prefs = { prefer_24:false, blank_ok:true, avoid_with:[] };
    memberAssignments = null;

    setRangeDefaults();
    await loadMember(getActiveMemberId());
  });
}

setRangeDefaults();
init();
</script>


<script>
(function(){
  function show(msg){
    try{
      var d=document.getElementById('scFatal');
      if(!d){
        d=document.createElement('div');
        d.id='scFatal';
        d.style.cssText='position:fixed;inset:0;z-index:99999;background:rgba(0,0,0,.85);color:#fff;padding:14px;font:14px/1.35 ui-monospace,Menlo,Consolas,monospace;overflow:auto;';
        d.innerHTML='<div style="font-weight:900;font-size:16px;margin-bottom:8px;">ShiftCommander error</div><pre id="scFatalMsg" style="white-space:pre-wrap;margin:0;"></pre>';
        document.body.appendChild(d);
      }
      var pre=document.getElementById('scFatalMsg');
      if(pre) pre.textContent=String(msg||'Unknown error');
    }catch(_e){}
  }
  window.addEventListener('error', function(e){
    show((e && (e.message||e.error)) ? (e.message||e.error) : e);
  });
  window.addEventListener('unhandledrejection', function(e){
    show('Unhandled Promise rejection: ' + (e && e.reason ? (e.reason.stack||e.reason.message||String(e.reason)) : 'unknown'));
  });
})();
</script>

</body>
</html>
