<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ShiftCommander — Member</title>
  <style>
    :root{
      --bg0:#070b14;
      --bg1:#0b1428;
      --card:#0c1a34;
      --card2:#0b1730;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.16);
      --text:#e9f1ff;
      --muted:rgba(233,241,255,.72);
      --muted2:rgba(233,241,255,.50);
      --green:#26d07c;
      --blue:#5c8dff;
      --red:#ff5d5d;
      --clear:rgba(233,241,255,.26);
      --shadow:0 16px 50px rgba(0,0,0,.35);
      --r:16px;
      --r2:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background: radial-gradient(1100px 700px at 35% -20%, #163a86 0%, rgba(22,58,134,0) 55%),
                  radial-gradient(900px 600px at 90% 0%, #2a0e6e 0%, rgba(42,14,110,0) 60%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
    }

    /* Header */
    .top{
      position:sticky;
      top:0;
      z-index:20;
      background: linear-gradient(180deg, rgba(5,8,16,.92), rgba(5,8,16,.55));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
    }
    .topInner{
      max-width: 1280px;
      margin: 0 auto;
      padding: 14px 14px 12px;
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .brand{
      font-weight:800;
      letter-spacing:.2px;
      margin-right:auto;
      white-space:nowrap;
    }
    .controls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      min-width: 320px;
    }
    .pill{
      background: rgba(255,255,255,.06);
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 9px 12px;
      display:flex;
      align-items:center;
      gap:10px;
      box-shadow: 0 8px 26px rgba(0,0,0,.18);
    }
    .pill label{font-size:12px; color:var(--muted2)}
    select, input[type="date"]{
      background: transparent;
      color: var(--text);
      border: 0;
      outline: 0;
      font-size: 14px;
    }
    option{color:#000}
    .btn{
      cursor:pointer;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 999px;
      padding: 9px 12px;
      font-weight: 700;
      box-shadow: 0 8px 26px rgba(0,0,0,.18);
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:active{transform: translateY(1px)}
    .btn:hover{background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.22)}
    .btn.secondary{font-weight:700; opacity:.95}

    .dot{
      width:10px; height:10px; border-radius:999px;
      background: var(--clear);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
      flex:0 0 auto;
    }
    .dot.ok{ background: var(--green); box-shadow: 0 0 0 3px rgba(38,208,124,.16) }
    .dot.warn{ background: #f4c542; box-shadow: 0 0 0 3px rgba(244,197,66,.16) }

    /* Layout */
    .wrap{
      max-width: 1280px;
      margin: 0 auto;
      padding: 16px 14px 18px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border: 1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .headline{
      display:flex;
      align-items:flex-start;
      gap:12px;
      flex-wrap:wrap;
    }
    .headline h2{
      margin:0;
      font-size: 16px;
      line-height:1.25;
      letter-spacing:.2px;
    }
    .headline .sub{
      margin:2px 0 0;
      font-size: 12px;
      color: var(--muted);
    }
    .headline .right{
      margin-left:auto;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .statusPill{
      display:flex;
      align-items:center;
      gap:10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
      padding: 8px 10px;
      min-height: 36px;
    }
    .statusPill .tiny{
      font-size:12px;
      color: var(--muted);
      max-width: 0; /* hide by default, keep tooltip */
      overflow:hidden;
      white-space:nowrap;
    }
    .statusPill.hasText .tiny{ max-width: 420px } /* use for debug if you ever want */
    .gridWrap{
      margin-top: 14px;
      overflow-x:auto;
      border-radius: var(--r);
    }

    /* Calendar grid */
    .cal{
      min-width: 980px; /* prevents off-screen clipping; scrolls instead */
      display:grid;
      grid-template-columns: 170px repeat(7, minmax(110px, 1fr));
      gap:10px;
      padding: 10px;
      background: rgba(0,0,0,.10);
      border: 1px solid var(--line);
      border-radius: var(--r);
    }
    .wkLabel{
      padding: 12px;
      border-radius: var(--r2);
      border: 1px solid var(--line);
      background: rgba(255,255,255,.035);
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
      min-height: 92px;
    }
    .wkTag{
      display:inline-flex;
      width:fit-content;
      align-items:center;
      gap:8px;
      font-size:12px;
      font-weight:800;
      letter-spacing:.3px;
      text-transform:uppercase;
      color: var(--muted);
    }
    .wkRange{
      font-size: 12px;
      color: var(--muted);
    }
    .wkRange b{color:var(--text)}
    .hdrCell{
      padding: 10px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      font-weight: 900;
      letter-spacing:.3px;
      text-transform:uppercase;
      font-size: 12px;
      color: var(--text);
      text-align:center;
    }

    .dayCard{
      border-radius: var(--r2);
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      padding: 10px;
      min-height: 92px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .dayTop{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:10px;
    }
    .dayNum{
      font-size: 26px;
      font-weight: 950;
      line-height:1;
      letter-spacing:.2px;
    }
    .dayMini{
      font-size: 11px;
      color: var(--muted2);
      letter-spacing:.2px;
      white-space:nowrap;
    }

    .shiftRow{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .shiftBtn{
      border-radius: 12px;
      padding: 10px 8px;
      border: 2px dashed rgba(233,241,255,.22);
      background: rgba(255,255,255,.02);
      cursor:pointer;
      user-select:none;
      text-align:center;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
    }
    .shiftBtn:active{ transform: translateY(1px) }
    .shiftBtn.locked{ cursor: not-allowed; opacity:.55 }
    .shiftKey{ font-weight: 950; letter-spacing:.3px; font-size: 12px; }
    .shiftState{ font-size: 10px; color: var(--muted2); margin-top: 3px; letter-spacing:.2px; text-transform:uppercase; }
    
    /* Preference fill (member choice) */
    .shiftBtn{ border: 2px solid rgba(233,241,255,.12); }
    .shiftBtn[data-state="preferred"]{ background: rgba(38,208,124,.22); }
    .shiftBtn[data-state="available"]{ background: rgba(92,141,255,.22); }
    .shiftBtn[data-state="nosched"]{ background: rgba(255,93,93,.22); }
    .shiftBtn[data-state="clear"]{ background: rgba(233,241,255,.06); border-style: dashed; }

    /* Heat border (Model A: Preferred popularity among eligible) */
    .shiftBtn[data-heat="need2"]{ border-color: rgba(38,208,124,.95); }
    .shiftBtn[data-heat="need1"]{ border-color: rgba(38,208,124,.55); }
    .shiftBtn[data-heat="neutral"]{ border-color: rgba(233,241,255,.18); }
    .shiftBtn[data-heat="crowd1"]{ border-color: rgba(255,168,54,.55); }
    .shiftBtn[data-heat="crowd2"]{ border-color: rgba(255,93,93,.92); }

    /* Pending Published change marker */
    .shiftBtn[data-pending="1"]{ position: relative; }
    .shiftBtn[data-pending="1"]::after{
      content:"";
      position:absolute;
      right:6px; top:6px;
      width:8px; height:8px;
      border-radius:99px;
      background: rgba(255,168,54,.95);
      box-shadow: 0 0 0 3px rgba(255,168,54,.18);
    }
.shiftBtn[data-state="worked"]{
      border-style: solid;
      border-color: rgba(233,241,255,.30);
      background: rgba(255,255,255,.03);
    }
    .shiftBtn[data-state="worked"] .shiftState{ color: rgba(233,241,255,.75) }

    /* Legend */
    .legend{
      margin-top: 12px;
      display:flex;
      flex-wrap:wrap;
      gap:10px 14px;
      align-items:center;
      color: var(--muted);
      font-size: 12px;
    }
    .legItem{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      cursor: help;
      user-select:none;
      white-space:nowrap;
    }
    .swatch{
      width: 10px; height: 10px; border-radius: 999px;
      background: rgba(233,241,255,.26);
      box-shadow: 0 0 0 3px rgba(255,255,255,.05);
    }
    .swatch.pref{ background: var(--green); box-shadow: 0 0 0 3px rgba(38,208,124,.16) }
    .swatch.av{ background: var(--blue); box-shadow: 0 0 0 3px rgba(92,141,255,.16) }
    .swatch.no{ background: var(--red); box-shadow: 0 0 0 3px rgba(255,93,93,.16) }
    .swatch.cl{ background: rgba(233,241,255,.26) }

    /* Modal (Repeat/Tools) */
    dialog{
      border:none;
      padding:0;
      border-radius: 18px;
      background: #0b1730;
      color: var(--text);
      width: min(720px, calc(100vw - 24px));
      box-shadow: 0 30px 80px rgba(0,0,0,.55);
    }
    dialog::backdrop{ background: rgba(0,0,0,.55) }
    .modalHead{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--line);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .modalHead h3{ margin:0; font-size: 15px }
    .modalBody{ padding: 14px }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
    .row > *{ flex: 0 0 auto }
    .note{ font-size: 12px; color: var(--muted); line-height: 1.35 }
    .danger{ border-color: rgba(255,93,93,.55) }
    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform: translateX(-50%);
      background: rgba(10,16,30,.92);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      padding: 10px 12px;
      color: var(--text);
      font-weight: 800;
      font-size: 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.50);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index:999;
    }
    .toast.show{ opacity:1 }

    @media (max-width: 860px){
      .controls{ min-width: unset; width:100% }
      .cal{ min-width: 900px }
      .wkLabel{ min-height: 86px }
    }
  </style>
</head>
<body>
<div style="position:fixed;bottom:6px;right:8px;z-index:9999;font-size:10px;color:#9ff;opacity:.55;pointer-events:none">MEMBER BUILD: fixed3 2025-12-28 15:19:33</div>
  <div class="top">
    <div class="topInner">
      <div class="brand">ShiftCommander — Member</div>

      <div class="controls">
        <div class="pill" title="Organization">
          <label>Org:</label>
          <span id="orgName" style="font-weight:900"></span>
        </div>

        <div class="pill" title="Select yourself">
          <label>Member:</label>
          <select id="memberSel"></select>
        </div>

        <button class="btn secondary" id="btnPrev">◀</button>
        <button class="btn secondary" id="btnThis">This Week</button>
        <button class="btn secondary" id="btnNext">▶</button>

        <div class="pill" title="Jump to a week start">
          <label>Week start:</label>
          <input id="weekPick" type="date"/>
        </div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="card">
      <div class="headline">
        <div>
          <h2>Set your availability</h2>
          <div class="sub">Tap AM/PM to cycle: Preferred → Available → Do not schedule → Clear.</div>
        </div>

        <div class="right">
          <div class="statusPill" id="savepill" title="Drive status">
            <span class="dot warn" id="driveDot"></span>
            <span class="tiny" id="driveTip">Checking…</span>
          </div>

          <div class="row" id="pendingQuick" style="display:none; gap:8px; align-items:center">
            <button class="btn secondary" id="btnUndoPendingQuick" title="Undo pending Published changes (revert locally)" style="padding:8px 10px;">Undo</button>
            <button class="btn secondary" id="btnPostPendingQuick" title="Commit pending Published changes now (sync to Drive)" style="padding:8px 10px;">Post</button>
          </div>
          <button class="btn" id="btnTools">Repeat / Tools</button>
        </div>
      </div>

      <div class="gridWrap">
        <div class="cal" id="cal"></div>
      </div>

      <div class="legend" aria-label="Availability legend">
        <span class="legItem" title="Preferred — You WANT this shift.">
          <span class="swatch pref"></span> Preferred
        </span>
        <span class="legItem" title="Available — You CAN work this shift and will be considered if not filled by someone who PREFERS it (then weighted fairly).">
          <span class="swatch av"></span> Available
        </span>
        <span class="legItem" title="Do not schedule — You will not be considered for this shift.">
          <span class="swatch no"></span> Do not schedule
        </span>
        <span class="legItem" title="Clear / unset — No preference stated. You may still be considered only if no one prefers or is available (and fairness allows it).">
          <span class="swatch cl"></span> Clear
        </span>
      </div>
    </div>
  </div>

  <dialog id="toolsDlg">
    <div class="modalHead">
      <h3>Repeat / Tools</h3>
      <div style="margin-left:auto"></div>
      <button class="btn secondary" id="btnCloseDlg">Close</button>
    </div>
    <div class="modalBody">
      <div class="note">
        Pick a <b>Pattern Week</b> (any week) and repeat it forward. The current work week may be restricted — your pattern doesn’t have to be.
      </div>

      <div style="height:10px"></div>

      <div class="row" style="align-items:center">
        <div class="pill" title="The week used as the source for repeats">
          <label>Pattern:</label>
          <span id="patternLabel" style="font-weight:900"></span>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="row">
        <button class="btn" id="copyPatternNext">Copy <b>Pattern</b> → next week</button>
        <button class="btn" id="copyPatternPublished">Copy <b>Pattern</b> → all <b>Published</b> weeks</button>
        <button class="btn danger" id="clearPatternWeek">Clear <b>Pattern</b> week</button>
      </div>

      <div style="height:14px"></div>

      <div style="border:1px solid var(--line); border-radius:16px; padding:12px; background: rgba(255,255,255,.03);">
        <div style="font-weight:900; margin-bottom:6px;">Repeat into Planning</div>
        <div class="note" style="margin-bottom:10px;">
          Repeat the <b>Pattern Week</b> every X weeks, starting in <b>Planning</b>, until the date you choose.
        </div>

        <div class="row" style="align-items:center">
          <label class="note">Every</label>
          <select id="repeatEvery" title="Repeat interval">
            <option value="2">2 weeks</option>
            <option value="4">4 weeks</option>
          </select>

          <label class="note">until</label>
          <input type="date" id="repeatUntil" title="Last date to fill (inclusive)"/>

          <button class="btn" id="btnRepeatPlanning">Repeat → Planning</button>
        </div>
      </div>

      <div style="height:12px"></div>

      <label class="note" style="display:flex; align-items:center; gap:10px; cursor:pointer; user-select:none">
        <input type="checkbox" id="overwriteLocks" style="transform:scale(1.1)" />
        Overwrite future manual picks (ignore locks)
      </label>
      <div style="height:12px"></div>

      <div class="row" style="align-items:center; gap:10px">
        <span class="note">Published safety:</span>
        <button class="btn secondary" id="btnPostPending" title="Commit pending Published changes now (sync to Drive)">Post pending now</button>
        <button class="btn secondary" id="btnUndoPending" title="Undo any pending Published changes (revert locally)">Undo pending</button>
        <span class="note" id="pendingHint" style="margin-left:auto"></span>
      </div>


      <div style="height:10px"></div>
      <div class="note">
        By default, repeats won’t overwrite future dates you already touched. Check “Overwrite…” only when you mean it.
      </div>
    </div>
  </dialog>

  <div class="toast" id="toast"></div>

<script>
/* =========================
   Config
========================= */
const ORG_SETTINGS_URL = "/data/org_settings.json";
const MEMBERS_URL      = "/data/members.json";

/* Google Apps Script JSON store (you already deployed this) */
const STORE_URL = "https://script.google.com/macros/s/AKfycbyHus2_cZOds7sCMxNlGzcJq0nEEtdZwS7JwKdlV-h0o_hctGCz1OpwANZ3nHLgOIa-ug/exec";

/* lead window + display window */
const LEAD_DAYS = 21;          // suppress supervisor-style “Needs…” until 3 weeks out (member page still allows edits)
const WEEKS_SHOWN = 7;         // current week + 6 upcoming (covers Managed + Published)         // editing week + 4 upcoming

/* =========================
   Helpers
========================= */
const $ = (id)=>document.getElementById(id);

function todayISO(){
  const t = new Date();
  return new Date(t.getFullYear(), t.getMonth(), t.getDate()).toISOString().slice(0,10);
}
function addDaysISO(dateISO, days){
  const d = new Date(dateISO + "T00:00:00");
  d.setDate(d.getDate()+days);
  return d.toISOString().slice(0,10);
}
function weekStartISO(anyDateISO){
  // week starts Thu (ADR’s planning cadence)
  const d = new Date(anyDateISO + "T00:00:00");
  const dow = d.getDay(); // 0 Sun..6 Sat
  const THU = 4;
  const delta = (dow - THU + 7) % 7;
  d.setDate(d.getDate() - delta);
  return d.toISOString().slice(0,10);
}

function daysBetweenISO(aISO, bISO){
  // Whole-day difference b - a
  const a = new Date(aISO + "T00:00:00Z").getTime();
  const b = new Date(bISO + "T00:00:00Z").getTime();
  return Math.round((b - a) / 86400000);
}

function fmtMD(dateISO){
  // no year anywhere
  const d = new Date(dateISO + "T00:00:00");
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return mm + "/" + dd;
}
function dayName(dateISO){
  // Thu, Fri, ...
  return ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][new Date(dateISO+"T00:00:00").getDay()];
}
function isPast(dateISO){
  return dateISO < todayISO();
}
function toast(msg){
  const t = $("toast");
  t.textContent = msg;
  t.classList.add("show");
  clearTimeout(toast._t);
  toast._t=setTimeout(()=>t.classList.remove("show"), 1600);
}

/* =========================
   Local + Remote State
========================= */
function lsKey(memberId){ return "sc_member_" + memberId; }
function lsMetaKey(memberId){ return "sc_member_meta_" + memberId; } // {dirty:boolean,lastPushISO,lastError:string}

function getLocal(memberId){
  try{ return JSON.parse(localStorage.getItem(lsKey(memberId)) || "{}"); }catch(e){ return {}; }
}
function setLocal(memberId, obj){
  localStorage.setItem(lsKey(memberId), JSON.stringify(obj));
}
function getMeta(memberId){
  try{ return JSON.parse(localStorage.getItem(lsMetaKey(memberId)) || "{}"); }catch(e){ return {}; }
}
function setMeta(memberId, meta){
  localStorage.setItem(lsMetaKey(memberId), JSON.stringify(meta));
}

async function storeGet(kind, memberId){
  try{
    const url = new URL(STORE_URL);
    url.searchParams.set("kind", kind);
    if(memberId) url.searchParams.set("memberId", memberId);
    const r = await fetch(url.toString(), { method:"GET", cache:"no-store" });
    if(!r.ok) throw new Error("store GET " + r.status);
    return await r.json();
  }catch(e){
    // Network/CORS/offline: treat as unavailable, but do NOT crash the page
    return { __error: String(e?.message || e) };
  }
}


async function storePut(kind, memberId, payload){
  try{
    const body = { kind, memberId, payload };
    const r = await fetch(STORE_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body),
    });
    if(!r.ok) throw new Error("store POST " + r.status);
    return await r.json();
  }catch(e){
    return { __error: String(e?.message || e) };
  }
}


/* auto-sync: if we had edits while “offline”, push when online resumes */
async function trySync(memberId){
  const meta = getMeta(memberId);
  if(!meta.dirty) return true;

  const payload = getLocal(memberId);

  const res = await storePut("member", memberId, payload);
  if(res && res.__error){
    meta.lastError = res.__error;
    setMeta(memberId, meta);
    setDriveStatus(meta);
    return false;
  }

  meta.dirty = false;
  meta.lastError = "";
  meta.lastPushISO = new Date().toISOString();
  setMeta(memberId, meta);
  setDriveStatus(meta);
  return true;
}


/* Drive status UI: only colors (green/yellow). Full meaning via hover tooltip. */
function setDriveStatus(meta){
  const tip = $("driveTip");
  const online = navigator.onLine !== false;

  let short = "Saved";
  if(meta && hasPending(meta)) short = "Pending";
  tip.textContent = short;

  // Dot: green when synced/normal, yellow when offline or remote error
  const dot = $("driveDot");
  const warn = (!online) || (meta && meta.lastError);
  dot.className = "dot " + (warn ? "warn" : "ok");

  const parts = [];
  parts.push("Saved locally on this device.");
  if(meta && hasPending(meta)){
    const ms = pendingRemainingMs(meta);
    parts.push(`Published changes pending (undo ${formatMinSec(ms)}).`);
    parts.push("Will sync to Drive after the undo window, or if you click ‘Post pending now’.");
  }else if(!online){
    parts.push("Offline: will sync to Drive when internet returns.");
  }else if(meta && meta.dirty){
    parts.push("Sync to Drive pending.");
  }else if(meta && meta.lastError){
    parts.push("Drive not reachable right now (still saved locally).");
  }else{
    parts.push("Synced to Drive.");
  }
  if(meta && meta.lastPushISO) parts.push("Last Drive sync: " + new Date(meta.lastPushISO).toLocaleString());
  if(meta && meta.lastError) parts.push("Drive sync issue: " + meta.lastError);
  $("savepill").title = parts.join(" ");
  updatePendingQuick();

}


/* =========================
   History (optional)
   Files live at /data/history/YYYY-MM.normalized.json (if present).
========================= */
const historyCache = new Map(); // "YYYY-MM" -> normalized month json

async function loadHistoryMonth(yyyyMM){
  if(historyCache.has(yyyyMM)) return historyCache.get(yyyyMM);
  try{
    const r = await fetch(`/data/history/${yyyyMM}.normalized.json`, { cache:"no-store" });
    if(!r.ok) throw new Error("history " + r.status);
    const j = await r.json();
    historyCache.set(yyyyMM, j);
    return j;
  }catch(e){
    historyCache.set(yyyyMM, null);
    return null;
  }
}
function memberWorked(historyMonth, dateISO, half, memberId){
  if(!historyMonth || !historyMonth.days || !historyMonth.days[dateISO]) return false;
  const d = historyMonth.days[dateISO];
  const obj = d[half];
  if(!obj) return false;
  // check any seat member_id match
  for(const k of Object.keys(obj)){
    const v = obj[k];
    if(v && typeof v === "object" && v.member_id && String(v.member_id) === String(memberId)){
      return true;
    }
  }
  return false;
}

/* =========================
   Availability Model
========================= */
const cycle = ["preferred","available","nosched","clear"];
const stateLabelTiny = {
  preferred:"Preferred",
  available:"Available",
  nosched:"Do not schedule",
  clear:"Clear",
  worked:"Worked"
};

function getStateFor(memberState, dateISO, half){
  return (memberState?.[dateISO]?.[half]) || "clear";
}
function setStateFor(memberState, dateISO, half, val){
  if(!memberState[dateISO]) memberState[dateISO] = {};
  memberState[dateISO][half] = val;
}

/* =========================
   Published Undo (30 min)
   - In Published weeks, changes are applied locally immediately,
     but remote sync is delayed to reduce accidental disruption.
   - Members can undo pending Published changes within the window.
========================= */
const UNDO_MINUTES_PUBLISHED = 30;

function stageForDateISO(dateISO){
  return weekTag(weekStartISO(dateISO)); // Past / Managed / Published / Planning
}

function getPendingMap(meta){
  // meta.pending = { "<dateISO>|<half>": {prev, next, createdAt, expiresAt} }
  if(!meta.pending || typeof meta.pending !== "object") meta.pending = {};
  return meta.pending;
}

function markPending(meta, dateISO, half, prevVal, nextVal){
  const key = `${dateISO}|${half}`;
  const now = Date.now();
  const expiresAt = now + UNDO_MINUTES_PUBLISHED*60*1000;
  const pending = getPendingMap(meta);
  if(!pending[key]){
    pending[key] = { prev: prevVal, next: nextVal, createdAt: now, expiresAt };
  }else{
    // keep original prev; update next; extend timer
    pending[key].next = nextVal;
    pending[key].expiresAt = expiresAt;
  }
  return key;
}

function clearPending(meta, key){
  const pending = getPendingMap(meta);
  delete pending[key];
}

function pendingRemainingMs(meta){
  const pending = getPendingMap(meta);
  let min = Infinity;
  for(const k in pending){
    const ms = (pending[k]?.expiresAt || 0) - Date.now();
    if(ms > 0 && ms < min) min = ms;
  }
  return (min===Infinity) ? 0 : min;
}

function formatMinSec(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const m = Math.floor(s/60);
  const r = s%60;
  return m>0 ? `${m}m ${String(r).padStart(2,'0')}s` : `${r}s`;
}

async function flushExpiredPending(memberId){
  const meta = getMeta(memberId);
  const pending = getPendingMap(meta);
  let changed = false;

  for(const key of Object.keys(pending)){
    const item = pending[key];
    if(!item) { delete pending[key]; changed = true; continue; }
    if(Date.now() >= (item.expiresAt || 0)){
      delete pending[key];
      changed = true;
    }
  }

  if(changed){
    setMeta(memberId, meta);
    // if nothing else is pending, try syncing the now-stable local state
    await trySync(memberId);
  }
}

function hasPending(meta){
  const pending = getPendingMap(meta);
  return Object.keys(pending).length > 0;
}

function setPendingUI(meta){
  // Keep lights green; change message only.
  if(hasPending(meta)){
    const ms = pendingRemainingMs(meta);
    const msg = ms ? `Pending changes (undo ${formatMinSec(ms)})` : "Pending changes";
    setSave(msg, "good");
  }

function applyPendingMarkers(){
  const meta = getMeta(memberId);
  const pending = getPendingMap(meta);
  document.querySelectorAll(".shiftBtn").forEach(btn=>{
    const k = `${btn.dataset.date}|${btn.dataset.half}`;
    if(pending[k]) btn.dataset.pending = "1";
    else btn.dataset.pending = "0";
  });
}
}

/* “manual lock” dates to prevent copy-overwrite:
   if user touched a specific date, we mark it locked in meta.locks[dateISO]=true */
function getLocks(memberId){
  const meta = getMeta(memberId);
  return meta.locks || {};
}

function getPatternWeek(memberId){
  const meta = getMeta(memberId);
  const v = meta.patternWeekStart;
  if(v) return v;
  // default: first Published week (next week after Managed)
  return addDaysISO(managedWeekStart, 7);
}
function setPatternWeek(startISO){
  patternWeekStart = startISO;
  const meta = getMeta(memberId);
  meta.patternWeekStart = startISO;
  setMeta(memberId, meta);
  updatePatternLabel();
  render();
}
function updatePatternLabel(){
  const el = $("patternLabel");
  if(!el) return;
  el.textContent = weekRangeLabel(patternWeekStart);
}
function setLocked(memberId, dateISO){
  const meta = getMeta(memberId);
  meta.locks = meta.locks || {};
  meta.locks[dateISO] = true;
  setMeta(memberId, meta);
}

/* =========================
   Render
========================= */
let orgSettings = null;
let members = [];
let memberId = null;
let editWeekStart = weekStartISO(todayISO());

let managedWeekStart = weekStartISO(todayISO());
let patternWeekStart = addDaysISO(managedWeekStart, 7); // default: first Published week

let memberState = {}; // availability map
let locks = {}; // dateISO -> true
let suppressEditPast = true;

function weekRangeLabel(startISO){
  const end = addDaysISO(startISO, 6);
  return `${fmtMD(startISO)} – ${fmtMD(end)}`;
}

function weekTag(startISO){
  const t = todayISO();
  const managedStart = managedWeekStart; // week start containing today
  const end = addDaysISO(startISO, 6);

  // Past (entire week ended before today)
  if(end < t) return "Past";

  // Compute week offset from the current Managed week start
  const diffDays = daysBetweenISO(managedStart, startISO);
  const w = Math.floor(diffDays / 7); // 0 = current week

  const MANAGED_WEEKS = 3;   // THIS week + 2 more
  const PUBLISHED_WEEKS = 3; // next 3 weeks after Managed

  if(w >= 0 && w < MANAGED_WEEKS) return "Managed";
  if(w >= MANAGED_WEEKS && w < (MANAGED_WEEKS + PUBLISHED_WEEKS)) return "Published";
  return "Planning";
}

function buildHeaderRow(container){
  // blank corner
  const corner = document.createElement("div");
  corner.className = "hdrCell";
  corner.style.opacity = ".85";
  corner.textContent = "Week";
  container.appendChild(corner);

  // day headers based on editWeekStart
  for(let i=0;i<7;i++){
    const dateISO = addDaysISO(editWeekStart, i);
    const h = document.createElement("div");
    h.className = "hdrCell";
    h.textContent = dayName(dateISO);
    container.appendChild(h);
  }
}

function buildWeekRow(container, startISO, idx){
  const tag = weekTag(startISO);

  const label = document.createElement("div");
  label.className = "wkLabel";
  const t = document.createElement("div");
  t.className = "wkTag";

  const dotClass = (tag==="Managed" || tag==="Published") ? "ok" : "warn";
  const isPattern = (startISO === patternWeekStart);

  t.innerHTML = `<span class="dot ${dotClass}"></span>${tag}${isPattern ? ' <span style="margin-left:6px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.04); font-size:11px; font-weight:950;">PATTERN</span>' : ''}`;

  const r = document.createElement("div");
  r.className = "wkRange";
  r.innerHTML = `<b>${weekRangeLabel(startISO)}</b>`;

  const pb = document.createElement("button");
  pb.className = "btn secondary";
  pb.style.padding = "7px 10px";
  pb.style.borderRadius = "999px";
  pb.style.fontSize = "12px";
  pb.textContent = "Set Pattern";
  pb.title = "Use this week as your repeating Pattern Week";
  pb.addEventListener("click", (ev)=>{ ev.stopPropagation(); setPatternWeek(startISO); });

  label.appendChild(t);
  label.appendChild(r);
  label.appendChild(pb);
  container.appendChild(label);

  for(let i=0;i<7;i++){
    const dateISO = addDaysISO(startISO, i);
    const day = document.createElement("div");
    day.className = "dayCard";

    const top = document.createElement("div");
    top.className = "dayTop";
    const num = document.createElement("div");
    num.className = "dayNum";
    num.textContent = String(new Date(dateISO+"T00:00:00").getDate());
    const mini = document.createElement("div");
    mini.className = "dayMini";
    mini.textContent = fmtMD(dateISO);
    top.appendChild(num);
    top.appendChild(mini);

    const row = document.createElement("div");
    row.className = "shiftRow";

    const isLockedPast = isPast(dateISO) && suppressEditPast;
    const isManualLocked = !!locks[dateISO];
    const editable = !isLockedPast;

    // optional history “worked” badge for past
    const monthKey = dateISO.slice(0,7);
    const hist = historyCache.get(monthKey) || null;

    for(const half of ["AM","PM"]){
      const btn = document.createElement("div");
      btn.className = "shiftBtn";
      btn.dataset.date = dateISO;
      btn.dataset.half = half;

      let state = getStateFor(memberState, dateISO, half);

      if(isPast(dateISO)){
        // If history says you worked, show that (read-only visual)
        if(hist && memberWorked(hist, dateISO, half, memberId)) state = "worked";
      }

      btn.dataset.state = state;
      btn.dataset.date = dateISO;
      btn.dataset.half = half;
      btn.dataset.heat = 'neutral';
      btn.title = `${dayName(dateISO)} ${fmtMD(dateISO)} ${half} — ${stateLabelTiny[state] || state}`;

      if(!editable || state==="worked"){
        btn.classList.add("locked");
      }

      const key = document.createElement("div");
      key.className = "shiftKey";
      key.textContent = half;

      const st = document.createElement("div");
      st.className = "shiftState";
      // TINY labels only
      st.textContent = state==="clear" ? "" : (state==="nosched" ? "NO" : (state==="preferred" ? "PREF" : (state==="available" ? "AVL" : state.toUpperCase())));
      btn.appendChild(key);
      btn.appendChild(st);

      btn.addEventListener("click", async ()=>{
        if(!editable) return;
        if(btn.dataset.state === "worked") return;

        const cur = btn.dataset.state || "clear";
        const nxt = cycle[(cycle.indexOf(cur)+1) % cycle.length];
        btn.dataset.state = nxt;
        btn.title = `${dayName(dateISO)} ${fmtMD(dateISO)} ${half} — ${stateLabelTiny[nxt]}`;
        st.textContent = nxt==="clear" ? "" : (nxt==="nosched" ? "NO" : (nxt==="preferred" ? "PREF" : "AVL"));

        // apply locally immediately
        setStateFor(memberState, dateISO, half, nxt);
        setLocal(memberId, memberState);
        setLocked(memberId, dateISO);

        const meta = getMeta(memberId);
        meta.dirty = true;

        const stage = stageForDateISO(dateISO);

        if(stage === "Published"){
          // 30-min undo window before remote sync
          const key = markPending(meta, dateISO, half, cur, nxt);
          btn.dataset.pending = "1";
          setMeta(memberId, meta);
          setDriveStatus(meta);
          setPendingUI(meta);
          toast("Pending (undo 30m)");
          // No immediate sync — will flush when expired or user posts via Tools
          return;
        }

        // Non-Published: sync normally (Planning + Managed + Past view edits)
        setMeta(memberId, meta);
        setDriveStatus(meta);

        // try push in background (doesn't block UI)
        const ok = await trySync(memberId);
        if(ok) toast("Saved");
      });

      row.appendChild(btn);
    }

    // subtle lock indicator if manual date exists (visual only)
    if(isManualLocked){
      day.style.borderColor = "rgba(233,241,255,.18)";
    }

    day.appendChild(top);
    day.appendChild(row);
    container.appendChild(day);
  }
}

async function render(){
  const cal = $("cal");
  cal.innerHTML = "";
  buildHeaderRow(cal);

  // preload history months for weeks shown (best-effort)
  const months = new Set();
  for(let w=0; w<WEEKS_SHOWN; w++){
    const ws = addDaysISO(editWeekStart, w*7);
    for(let i=0;i<7;i++) months.add(addDaysISO(ws,i).slice(0,7));
  }
  await Promise.all([...months].map(loadHistoryMonth));

  // stitch loaded history into cache (loadHistoryMonth stored null on failure)
  for(const m of months){
    if(!historyCache.has(m)){
      // loadHistoryMonth stores to cache, but in case it didn't:
      historyCache.set(m, null);
    }
  }

  for(let w=0; w<WEEKS_SHOWN; w++){
    buildWeekRow(cal, addDaysISO(editWeekStart, w*7), w);
  }
  // Heat borders (best-effort)
  if(HEAT && HEAT.ready) applyHeatToUI();
  if(memberId) if (typeof applyPendingMarkers==='function') applyPendingMarkers();
}

/* =========================
   Repeat / Tools
========================= */
function copyWeekPattern(srcWeekStartISO, dstWeekStartISO, respectLocks=true){
  // copies availability from src week -> dst week
  // Default: SKIPS future dates you already touched (manual locks).
  for(let i=0;i<7;i++){
    const srcDay = addDaysISO(srcWeekStartISO, i);
    const dstDay = addDaysISO(dstWeekStartISO, i);
    if(respectLocks && locks[dstDay]) continue; // don't overwrite hand-picked dates unless requested
    for(const half of ["AM","PM"]){
      const v = getStateFor(memberState, srcDay, half);
      setStateFor(memberState, dstDay, half, v);
    }
  }
}
async function persistAfterBulkEdit(){
  setLocal(memberId, memberState);
  const meta = getMeta(memberId);
  meta.dirty = true;
  setMeta(memberId, meta);
  setDriveStatus(meta);
  await render();
  const ok = await trySync(memberId);
  if(ok) toast("Saved");
}
$("btnTools").addEventListener("click", ()=> { updatePatternLabel(); updatePendingHint(); $("toolsDlg").showModal(); });
$("btnCloseDlg").addEventListener("click", ()=> $("toolsDlg").close());

$("copyPatternNext").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks")?.checked === true;
  copyWeekPattern(patternWeekStart, addDaysISO(patternWeekStart, 7), !overwrite);
  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

$("copyPatternPublished").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks")?.checked === true;
  // Published = next 3 weeks after Managed
  const pubStart = addDaysISO(managedWeekStart, 7*3); // after Managed (3 weeks)
  for(let w=0; w<3; w++){
    const dst = addDaysISO(pubStart, w*7);
    copyWeekPattern(patternWeekStart, dst, !overwrite);
  }
  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

$("clearPatternWeek").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks")?.checked === true;
  for(let i=0;i<7;i++){
    const day = addDaysISO(patternWeekStart, i);
    if(!overwrite && locks[day]) continue;
    for(const half of ["AM","PM"]){
      setStateFor(memberState, day, half, "clear");
    }
  }
  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

function planningWeekStart(){
  // Planning begins after 3 Managed + 3 Published weeks
  return addDaysISO(managedWeekStart, 7*(3+3)); // 3 Managed + 3 Published
}


function updatePendingHint(){
  const meta = getMeta(memberId);
  const p = getPendingMap(meta);
  const keys = Object.keys(p);
  if(!$("pendingHint")) return;
  if(keys.length === 0){ $("pendingHint").textContent = ""; return; }
  const ms = pendingRemainingMs(meta);
  $("pendingHint").textContent = `${keys.length} pending • undo ${formatMinSec(ms)}`;
}

$("btnPostPending")?.addEventListener("click", async ()=>{
  const meta = getMeta(memberId);
  const p = getPendingMap(meta);
  const keys = Object.keys(p);
  if(keys.length === 0){ toast("No pending changes"); return; }
  // Commit: clear pending and sync now
  meta.pending = {};
  setMeta(memberId, meta);
  setDriveStatus(meta);
  const ok = await trySync(memberId);
  render();
  if(HEAT && HEAT.ready) applyHeatToUI();
  toast(ok ? "Posted" : "Posted (local), sync pending");
  $("toolsDlg").close();
});

$("btnUndoPending")?.addEventListener("click", async ()=>{
  const meta = getMeta(memberId);
  const p = getPendingMap(meta);
  const keys = Object.keys(p);
  if(keys.length === 0){ toast("No pending changes"); return; }

  // Revert locally to previous values
  for(const k of keys){
    const [dateISO, half] = k.split("|");
    const item = p[k];
    if(!dateISO || !half || !item) continue;
    setStateFor(memberState, dateISO, half, item.prev || "clear");
  }
  meta.pending = {};
  setLocal(memberId, memberState);
  setMeta(memberId, meta);
  setDriveStatus(meta);
  render();
  if(HEAT && HEAT.ready) applyHeatToUI();
  toast("Undone");
  $("toolsDlg").close();
});
$("btnRepeatPlanning").addEventListener("click", async ()=>{
  const overwrite = $("overwriteLocks")?.checked === true;
  const every = parseInt($("repeatEvery")?.value || "4", 10);
  const until = $("repeatUntil")?.value || "";

  if(!until){
    toast("Pick an 'until' date");
    return;
  }
  const untilWeek = weekStartISO(until);
  const startPlanning = planningWeekStart();

  // Repeat pattern forward every N weeks, but only fill Planning weeks.
  for(let wStart = patternWeekStart; wStart <= untilWeek; ){
    // advance first (we don't need to "repeat" into the pattern itself)
    wStart = addDaysISO(wStart, every*7);
    if(wStart > untilWeek) break;
    if(addDaysISO(wStart, 6) < todayISO()) continue; // skip fully past
    if(wStart < startPlanning) continue; // keep this button "Planning only"
    copyWeekPattern(patternWeekStart, wStart, !overwrite);
  }

  await persistAfterBulkEdit();
  $("toolsDlg").close();
});

// Quick pending buttons (visible only when something is pending)
function updatePendingQuick(){
  const meta = getMeta(memberId);
  const show = !!(meta && hasPending(meta));
  const box = $("pendingQuick");
  if(!box) return;
  box.style.display = show ? "flex" : "none";
}

$("btnPostPendingQuick")?.addEventListener("click", async ()=>{
  $("btnPostPending")?.click();
});
$("btnUndoPendingQuick")?.addEventListener("click", async ()=>{
  $("btnUndoPending")?.click();
});

/* =========================
   Boot
========================= */

/* =========================
   Heat Map (Model A)
   Border shows popularity among eligible members:
   - Green = low Preferred interest (high need)
   - Neutral = average
   - Red = crowded
   Only counts "preferred".
========================= */
let HEAT = { ready:false, byKey:{}, eligibleCount:0, loadedAt:0, lastError:"" };

function heatKey(dateISO, half){ return `${dateISO}|${half}`; }

function eligibleMembers(){
  // Model A: eligible = active members (qual filters can be added later)
  return (members || []).filter(m => m && m.active !== false);
}

function classifyHeat(ratio, E, R){
  // small-roster correction
  if(E < 4){
    if(R <= 0) return "need2";
    if(R == 1) return "need1";
    if(R == 2) return "neutral";
    return "crowd2";
  }
  if(ratio < 0.10) return "need2";
  if(ratio < 0.25) return "need1";
  if(ratio < 0.50) return "neutral";
  if(ratio < 0.75) return "crowd1";
  return "crowd2";
}

async function loadHeat(){
  try{
    const elig = eligibleMembers();
    const E = elig.length;
    HEAT.eligibleCount = E;
    if(E === 0){ HEAT.ready = true; HEAT.byKey = {}; return; }

    const all = await storeGet("member");
    if(all && all.__error) throw new Error(all.__error); // expected: array of {memberId,payload} or object
    const payloads = [];

    if(Array.isArray(all)){
      for(const item of all){
        if(item && item.payload) payloads.push(item.payload);
      }
    }else if(all && typeof all === "object"){
      // common wrapper forms
      if(Array.isArray(all.items)){
        for(const item of all.items){
          if(item && item.payload) payloads.push(item.payload);
        }
      }else if(all.payload){
        // single payload (unlikely for list) — ignore
      }else{
        // maybe { "102": {payload...}, ... }
        for(const k of Object.keys(all)){
          const item = all[k];
          if(item && item.payload) payloads.push(item.payload);
        }
      }
    }

    const counts = {}; // key -> R preferred count
    for(const st of payloads){
      if(!st || typeof st !== "object") continue;
      for(const dateISO of Object.keys(st)){
        const day = st[dateISO];
        if(!day || typeof day !== "object") continue;
        for(const half of Object.keys(day)){
          if(day[half] === "preferred"){
            const k = heatKey(dateISO, half);
            counts[k] = (counts[k] || 0) + 1;
          }
        }
      }
    }

    const byKey = {};
    for(const k of Object.keys(counts)){
      const R = counts[k] || 0;
      const ratio = R / E;
      byKey[k] = { R, E, ratio, level: classifyHeat(ratio, E, R) };
    }

    HEAT.byKey = byKey;
    HEAT.ready = true;
    HEAT.loadedAt = Date.now();
    HEAT.lastError = "";
  }catch(e){
    console.warn("Heat load failed:", e);
    HEAT.ready = false;
    HEAT.lastError = String(e?.message || e);
  }
}

function applyHeatToUI(){
  const grid = $("grid");
  if(!grid) return;
  grid.querySelectorAll(".shiftBtn").forEach(btn=>{
    const dateISO = btn.dataset.date;
    const half = btn.dataset.half;
    if(!dateISO || !half) return;

    const stage = stageForDateISO(dateISO);
    if(stage !== "Published" && stage !== "Planning"){
      btn.dataset.heat = "neutral";
      return;
    }

    const k = heatKey(dateISO, half);
    const h = HEAT.byKey[k];
    btn.dataset.heat = h ? h.level : "need2"; // if nobody preferred yet, it's needed
    // enrich tooltip (keep short)
    if(h){
      const pct = Math.round(h.ratio*100);
      btn.title = btn.title + `\nPopularity: ${h.R}/${h.E} eligible prefer (${pct}%).`;
    }else if(HEAT.eligibleCount){
      btn.title = btn.title + `\nPopularity: 0/${HEAT.eligibleCount} eligible prefer (0%).`;
    }
  });
}
async function loadRequired(){
  const [orgR, memR] = await Promise.all([
    fetch(ORG_SETTINGS_URL, {cache:"no-store"}),
    fetch(MEMBERS_URL, {cache:"no-store"})
  ]);
  if(!orgR.ok) throw new Error("Fetch failed " + orgR.status + ": " + ORG_SETTINGS_URL);
  if(!memR.ok) throw new Error("Fetch failed " + memR.status + ": " + MEMBERS_URL);

  orgSettings = await orgR.json();

  const memJson = await memR.json();

  // Accept BOTH shapes:
  // 1) legacy: [ {id, first, last, ...}, ... ]
  // 2) current: { version, updated_at, members: [ {member_id, first_name, last_name, ...}, ... ] }
  let rawMembers = memJson;
  if(Array.isArray(memJson)) rawMembers = memJson;
  else if(memJson && Array.isArray(memJson.members)) rawMembers = memJson.members;
  else throw new Error("members is not iterable (unexpected members.json shape)");

  // Normalize to the fields this page uses
  members = rawMembers.map(m => ({
    // unify id field
    id: String(m.id ?? m.member_id ?? ""),
    first: (m.first ?? m.first_name ?? "").trim(),
    last: (m.last ?? m.last_name ?? "").trim(),
    active: (m.active !== false),
    _raw: m
  })).filter(m => m.id);

  // Org name (supports both shapes)
  const orgName = orgSettings?.org_name || orgSettings?.org?.name || "Org";
  $("orgName").textContent = orgName;

  // member dropdown
  const sel = $("memberSel");
  sel.innerHTML = "";
  for(const m of members){
    const opt = document.createElement("option");
    opt.value = m.id;
    opt.textContent = `${m.last || ""}, ${m.first || ""} #${m.id}`;
    sel.appendChild(opt);
  }
  memberId = String(members?.[0]?.id || "");
  sel.value = memberId;
}

async function loadMember(){
  managedWeekStart = weekStartISO(todayISO());
  patternWeekStart = getPatternWeek(memberId);
  locks = getLocks(memberId);

  // start with local
  memberState = getLocal(memberId) || {};
  let meta = getMeta(memberId);

  // show “ok” if last push exists and not dirty
  const optimisticOk = !!meta.lastPushISO && !meta.dirty && (navigator.onLine !== false);
  setDriveStatus(meta);

  // pull remote if available, but do NOT clobber local if local is dirty
  try{
    const remote = await storeGet("member", memberId);
    if(remote && remote.__error){
      meta.lastError = remote.__error;
      setMeta(memberId, meta);
      setDriveStatus(meta);
    } else if(remote && remote.payload){
      if(!meta.dirty){
        memberState = remote.payload;
        setLocal(memberId, memberState);
      }
      meta.lastError = "";
      setMeta(memberId, meta);
      setDriveStatus(meta);
    }
  }catch(e){
    meta.lastError = String(e.message || e);
    setMeta(memberId, meta);
    setDriveStatus(meta);
  }

  // if we had dirty edits, try sync once on load
  await trySync(memberId);

  updatePatternLabel();
  await render();
}

function setEditWeekStart(newStartISO){
  editWeekStart = weekStartISO(newStartISO);
  $("weekPick").value = editWeekStart;
  render();
}

$("memberSel").addEventListener("change", async (e)=>{
  memberId = String(e.target.value);
  await loadMember();
});

$("btnPrev").addEventListener("click", ()=>{
  setEditWeekStart(addDaysISO(editWeekStart, -7));
});
$("btnNext").addEventListener("click", ()=>{
  setEditWeekStart(addDaysISO(editWeekStart, 7));
});
$("btnThis").addEventListener("click", ()=>{
  setEditWeekStart(todayISO());
});
$("weekPick").addEventListener("change", (e)=>{
  if(e.target.value) setEditWeekStart(e.target.value);
});

// Online/offline events: if we come back online, push dirty edits automatically
window.addEventListener("online", ()=> { if(memberId) trySync(memberId); });
window.addEventListener("offline", ()=> { if(memberId){ const m=getMeta(memberId); setDriveStatus(m);} });

(async function boot(){
  try{
    await loadRequired();
    setEditWeekStart(todayISO());
    // default "repeat until" = 6 months out
    const ru = $("repeatUntil");
    if(ru){
      const d = new Date();
      d.setMonth(d.getMonth()+6);
      ru.value = d.toISOString().slice(0,10);
    }
    await loadMember();

    // Heat map load (best-effort)
    loadHeat().then(()=>{ HEAT.ready = true; applyHeatToUI(); }).catch(()=>{});

    // Pending Published countdown + auto-flush
    if(memberId){
      const tick = async ()=>{
        const meta = getMeta(memberId);
        if(hasPending(meta)){
          setPendingUI(meta);
          updatePendingHint();
          await flushExpiredPending(memberId);
          // refresh pending markers
          if (typeof applyPendingMarkers==='function') applyPendingMarkers();
        }
      };
      setInterval(()=>{ tick().catch(()=>{}); }, 15000);
      tick().catch(()=>{});
    }
  }catch(e){
    alert("Member page failed to load required data:\n\n" + (e.message || e));
    console.error(e);
  }
})();
</script>
</body>
</html>
